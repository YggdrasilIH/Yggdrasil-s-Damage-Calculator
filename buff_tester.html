<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>15-Round Battle Simulator</title>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #e0e0e0;
    padding: 20px;
  }
  button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin-bottom: 15px;
  }
  pre {
    background: #1e1e1e;
    padding: 15px;
    max-height: 45vh;
    overflow-y: auto;
    white-space: pre-wrap;
    border-radius: 6px;
  }
  canvas {
    background: #1e1e1e;
    margin-top: 20px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<h1>15-Round Battle Simulator</h1>
<button onclick="runSimulation()">Run Simulation</button>

<pre id="log"></pre>

<canvas id="curseChart" width="800" height="250"></canvas>
<canvas id="buffChart" width="800" height="250"></canvas>

<script>
/* =========================
   LOGGING
========================= */

const logEl = document.getElementById("log");
function log(msg) {
  logEl.textContent += msg + "\n";
}

/* =========================
   RNG
========================= */

function rng50() {
  return Math.random() < 0.5;
}

/* =========================
   LFA STATE
========================= */

const LFA = {
  buffs: [],
  curseStacks: 0
};

/* =========================
   HISTORY TRACKING
========================= */

let curseHistory = [];
let buffHistory = [];

/* =========================
   BUFF APPLICATION
========================= */

function applyBuffToLFA(buff) {
  if (buff.type === "ALL_DAMAGE_DEALT") {
    LFA.buffs.push(buff);
    log(`  ✔ Buff applied (immune): ${buff.name}`);
    return;
  }

  if (LFA.curseStacks > 0) {
    LFA.curseStacks--;
    log(`  ✖ Buff negated: ${buff.name} (Curse left: ${LFA.curseStacks})`);
  } else {
    LFA.buffs.push(buff);
    log(`  ✔ Buff applied: ${buff.name}`);
  }
}

/* =========================
   HERO ACTIONS
========================= */

function vesperaAction(round) {
  log(" Vespera attacks");

  ["10 Attack", "10 Damage Reduction", "10 Control Immunity", "30 Speed"]
    .forEach(name => applyBuffToLFA({ name, type: "NORMAL" }));

  if (round % 2 === 1) {
    applyBuffToLFA({ name: "Attack Steal", type: "NORMAL" });
    applyBuffToLFA({ name: "All Damage Dealt", type: "ALL_DAMAGE_DEALT" });
    applyBuffToLFA({ name: "Crit Damage", type: "NORMAL" });
  } else {
    applyBuffToLFA({ name: "Crit", type: "NORMAL" });
  }

  applyBuffToLFA({ name: "Energy (DB)", type: "NORMAL" });
}

function lbrmAction() {
  log(" LBRM attacks");
  applyBuffToLFA({ name: "All Damage Dealt", type: "ALL_DAMAGE_DEALT" });
}

function genericAttack(name) {
  log(` ${name} attacks`);
}

/* =========================
   TEAM 2 LOGIC
========================= */

function team2Counter() {
  if (rng50()) {
    LFA.curseStacks++;
    log(`  ⚠ Counter: +1 Curse (Total: ${LFA.curseStacks})`);
  }
}

function team2Turn() {
  log(" Team 2 attacks");
  LFA.curseStacks += 2;
  log(`  ⚠ +2 Curse (Total: ${LFA.curseStacks})`);

  applyBuffToLFA({ name: "Crit (SQH reaction)", type: "NORMAL" });
  applyBuffToLFA({ name: "All Damage Dealt (PDE)", type: "ALL_DAMAGE_DEALT" });
  applyBuffToLFA({ name: "All Damage Dealt (PDE)", type: "ALL_DAMAGE_DEALT" });
  applyBuffToLFA({ name: "Holy Damage (PDE)", type: "NORMAL" });
}

/* =========================
   END OF ROUND
========================= */

function endOfRoundTeam1() {
  log(" End of Round – Team 1");

  applyBuffToLFA({ name: "Energy (Mirror)", type: "NORMAL" });
  applyBuffToLFA({ name: "All Damage Dealt (Mirror)", type: "ALL_DAMAGE_DEALT" });

  applyBuffToLFA({ name: "Attack (Scissors SQH)", type: "NORMAL" });
  applyBuffToLFA({ name: "Holy Damage (Scissors PDE)", type: "NORMAL" });
  applyBuffToLFA({ name: "Holy Damage (Scissors LBRM)", type: "NORMAL" });
}

function endOfRoundTeam2() {
  LFA.curseStacks += 3;
  log(` ⚠ End of Round: +3 Curse (Total: ${LFA.curseStacks})`);
}

/* =========================
   GRAPHING
========================= */

function drawGraph(canvasId, data, label) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const maxVal = Math.max(...data, 1);
  const padding = 40;
  const stepX = (canvas.width - padding * 2) / (data.length - 1);

  ctx.strokeStyle = "#4cafef";
  ctx.beginPath();

  data.forEach((val, i) => {
    const x = padding + stepX * i;
    const y = canvas.height - padding - (val / maxVal) * (canvas.height - padding * 2);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });

  ctx.stroke();

  ctx.fillStyle = "#ccc";
  ctx.fillText(label, padding, 20);
}

/* =========================
   MAIN SIMULATION
========================= */

function runSimulation() {
  logEl.textContent = "";
  LFA.buffs = [];
  LFA.curseStacks = 0;
  curseHistory = [];
  buffHistory = [];

  const heroes = ["Vespera", "LFA", "Elyvia", "SQH", "PDE", "LBRM"];

  for (let round = 1; round <= 15; round++) {
    log(`\n===== ROUND ${round} =====`);

    for (const hero of heroes) {
      if (hero === "Vespera") vesperaAction(round);
      else if (hero === "LBRM") lbrmAction();
      else genericAttack(hero);

      team2Counter();
    }

    team2Turn();
    endOfRoundTeam1();
    endOfRoundTeam2();

    curseHistory.push(LFA.curseStacks);
    buffHistory.push(LFA.buffs.length);

    log(` Buffs on LFA: ${LFA.buffs.map(b => b.name).join(", ")}`);
    log(` Curse stacks end of round: ${LFA.curseStacks}`);
  }

  drawGraph("curseChart", curseHistory, "Curse of Decay Stacks per Round");
  drawGraph("buffChart", buffHistory, "Total Buffs on LFA per Round");
}
</script>

</body>
</html>
