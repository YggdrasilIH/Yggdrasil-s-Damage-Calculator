<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Battle Simulator</title>
<style>
  body { font-family: Arial, sans-serif; background: #f5f4eb; padding: 20px; }
  h1 { color: #333; }
  select, button { margin: 5px; }
  pre { background: #ddd; padding: 10px; overflow-x: auto; white-space: pre-wrap; }
</style>
</head>
<body>

<h1>Battle Simulator</h1>

<div id="heroSelection">
  <h2>Select Heroes (Speed Order)</h2>
  <div id="heroes"></div>
  <button onclick="startSimulation()">Start Simulation</button>
</div>

<h2>Round-by-Round Timeline</h2>
<pre id="timeline"></pre>

<script>
// -------------------- Hero & Artifact Definitions --------------------
const heroTemplates = {
  SQH: { name: "SQH", DTThreshold: 12, energy:0, transitionPoints:0, artifact:"none" },
  Ely: { name: "Ely", DTThreshold:null, energy:0, transitionPoints:0, artifact:"none" },
  LFA: { name: "LFA", DTThreshold:null, energy:0, transitionPoints:0, artifact:"none" },
  LBRM: { name: "LBRM", DTThreshold:6, energy:0, transitionPoints:0, artifact:"none" },
  BDSM: { name: "BDSM", DTThreshold:null, energy:0, transitionPoints:0, artifact:"none" },
  Vespera: { name: "Vespera", DTThreshold:6, energy:0, transitionPoints:0, artifact:"none" },
  PDE: { name: "PDE", DTThreshold:null, energy:0, transitionPoints:0, artifact:"none" }
};
const artifactOptions = ["mirror","db","scissors","antlers","none"];
const buffStats = ["atk","speed","HD","CI","ADD","critRate","critDamage","DR","energy","armor","atkSteal"];

// -------------------- Utility Functions --------------------
function setHeroEnergy(hero, value){ hero.energy = Math.max(0,value); }

function tryApplyBuff(heroBuffPool, buff){
  if(!heroBuffPool[buff.stat]) heroBuffPool[buff.stat]=[];
  heroBuffPool[buff.stat].push({...buff});
}

function decrementBuffs(buffPool){
  for(const stat in buffPool){
    buffPool[stat] = buffPool[stat].filter(b=>b.duration>1?(--b.duration,true):false);
    if(buffPool[stat].length===0) delete buffPool[stat];
  }
}

function removeRandomBuffFromHero(heroBuffPool){
  const stats = Object.keys(heroBuffPool);
  if(stats.length===0) return;
  const statToRemove = stats[Math.floor(Math.random()*stats.length)];
  heroBuffPool[statToRemove] = [];
  delete heroBuffPool[statToRemove];
}

// -------------------- Battle State --------------------
let battleState = {
  round:1,
  heroes:[],
  boss:{ HDStacks:0, atkBuff:0, counterCount:0, abyssalCorruption:0 },
  timeline:[]
};

// -------------------- Hero Actions --------------------
function applyHeroAction(hero, actionType){
  // Active consumes energy
  if(actionType==="active"){
    if(hero.name==="LBRM"){ setHeroEnergy(hero,0); tryGainEnergy(hero,50); } 
    else setHeroEnergy(hero,0);
  }

  if(!hero.buffPool) hero.buffPool={};

  // Hero-specific buffs
  switch(hero.name){
    case "SQH":
      if(actionType==="active"){
        battleState.boss.abyssalCorruption++;
        if(Math.random()<0.25) battleState.boss.abyssalCorruption++;
      }
      if(hero.transitionPoints>=12){
        hero.transitionPoints=0;
        battleState.heroes.forEach(h=>{
          tryApplyBuff(h.buffPool,{stat:"energy",value:20,duration:1,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"armor",value:0.2,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"DR",value:0.2,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"atk",value:0.1,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"ADD",value:0.1,duration:2,offsettable:false});
        });
      }
      break;
    case "LBRM":
      tryApplyBuff(hero.buffPool,{stat:"ADD",value:0.12,duration:4,offsettable:false});
      if(hero.transitionPoints>=6){
        hero.transitionPoints=0;
        battleState.heroes.forEach(h=>{
          tryApplyBuff(h.buffPool,{stat:"HD",value:0.1,duration:2,offsettable:true});
          if(h.name==="LFA") tryApplyBuff(h.buffPool,{stat:"ADD",value:0.15,duration:2,offsettable:false});
          if(h.name==="LFA") tryApplyBuff(h.buffPool,{stat:"ADD",value:0.1,duration:3,offsettable:false});
        });
      }
      break;
    case "Vespera":
      if(actionType==="basic"){
        tryApplyBuff(hero.buffPool,{stat:"atk",value:0.1,duration:2,offsettable:true});
        if(Math.random()<0.8) tryApplyBuff(hero.buffPool,{stat:"ADD",value:0.08,duration:2,offsettable:false});
      }
      if(actionType==="active"){
        battleState.heroes.forEach(h=>{
          tryApplyBuff(h.buffPool,{stat:"atk",value:0.1,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"armor",value:0.1,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"DR",value:0.1,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"CI",value:0.1,duration:2,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"speed",value:30,duration:2,offsettable:true});
        });
      }
      if(hero.transitionPoints>=6){
        battleState.heroes.forEach(h=>{
          tryApplyBuff(h.buffPool,{stat:"energy",value:20,duration:1,offsettable:true});
          tryApplyBuff(h.buffPool,{stat:"atk",value:0.1,duration:2,offsettable:true});
        });
      }
      if(hero.transitionPoints>=12){
        hero.transitionPoints=0;
        battleState.heroes.forEach(h=>{
          tryApplyBuff(h.buffPool,{stat:"ADD",value:0.1,duration:2,offsettable:false});
        });
      }
      break;
    case "LFA":
      if(actionType==="basic") tryApplyBuff(hero.buffPool,{stat:"critRate",value:0.24,duration:4,offsettable:true});
      if(actionType==="active"){
        tryApplyBuff(hero.buffPool,{stat:"critRate",value:0.5,duration:2,offsettable:true});
        tryApplyBuff(hero.buffPool,{stat:"critDamage",value:1.0,duration:2,offsettable:true});
        tryApplyBuff(hero.buffPool,{stat:"atkSteal",value:0.3,duration:15,offsettable:false});
      }
      break;
    case "PDE":
      // handled on boss attack phase
      break;
  }

  // Individual post-action buffs
  if(actionType==="basic"){
    tryGainEnergy(hero,150);
    tryApplyBuff(hero.buffPool,{stat:"ADD",value:0.35,duration:15,offsettable:false});
  }
  if(actionType==="active"){
    tryApplyBuff(hero.buffPool,{stat:"critRate",value:0.5,duration:2,offsettable:true});
    tryApplyBuff(hero.buffPool,{stat:"critDamage",value:1.0,duration:2,offsettable:true});
  }

  if(hero.transitionPoints!==undefined && actionType==="active") hero.transitionPoints+=6;

  applyArtifactOnHeroAction(hero);
}

// -------------------- Energy/Buffs Functions --------------------
function tryGainEnergy(hero, amount){
  hero.energy = Math.max(0, (hero.energy||0) + amount);
}

// -------------------- SE Boss Functions --------------------
function seBossNormalAttack(){
  battleState.heroes.forEach(h=>{
    if(h.name!=="LFA"){
      tryApplyBuff(h.buffPool,{stat:"atk",value:-0.08,duration:3,offsettable:true});
      tryApplyBuff(h.buffPool,{stat:"CI",value:0.15,duration:3,offsettable:true});
      tryApplyBuff(h.buffPool,{stat:"DR",value:0.1,duration:1,offsettable:true});
    }
  });
}

function bossEndOfRound(){
  battleState.boss.HDStacks+=0.12*2;
  battleState.boss.atkBuff+=0.15;
  battleState.heroes.forEach(h=>{
    if(Math.random()<0.25) removeRandomBuffFromHero(h.buffPool);
    setHeroEnergy(h,h.energy-100);
    tryApplyBuff(h.buffPool,{stat:"atk",value:-0.35,duration:1,offsettable:true});
  });
  battleState.heroes.forEach(h=>{ // PDE DT on boss attack
    if(h.name==="PDE"){
      if(h.transitionPoints>=3) battleState.heroes.forEach(a=>{
        tryApplyBuff(a.buffPool,{stat:"HD",value:0.1,duration:2,offsettable:true});
        if(a.name==="LFA") tryApplyBuff(a.buffPool,{stat:"ADD",value:0.15,duration:2,offsettable:false});
      });
      if(h.transitionPoints>=6) battleState.heroes.forEach(a=>{
        tryApplyBuff(a.buffPool,{stat:"ADD",value:0.2,duration:3,offsettable:false});
      });
      if(h.transitionPoints>=18) h.transitionPoints-=18;
    }
  });
}

// -------------------- Island Buffs --------------------
function applyIslandStartRound(){
  battleState.heroes.forEach(h=>{
    tryApplyBuff(h.buffPool,{stat:"ADD",value:0.25,duration:2,offsettable:true});
    tryApplyBuff(h.buffPool,{stat:"atk",value:0.35,duration:2,offsettable:true});
    tryApplyBuff(h.buffPool,{stat:"HD",value:0.1,duration:15,offsettable:true});
  });
}
function applyIslandEndRound(){
  battleState.heroes.forEach(h=>tryGainEnergy(h,50));
}

// -------------------- Artifact Functions --------------------
function applyArtifactOnHeroAction(hero){
  if(hero.artifact==="db"){
    tryGainEnergy(hero,20);
    if(Math.random()<0.5) tryGainEnergy(hero,10);
  }
  if(hero.artifact==="mirror"){
    tryGainEnergy(hero,75); // round 1 bonus handled in initialization
  }
  if(hero.artifact==="antlers"){
    tryApplyBuff(hero.buffPool,{stat:"ADD",value:0.09,duration:15,offsettable:false});
  }
  if(hero.artifact==="scissors"){
    // Copy boss buffs
    ["HD","atk"].forEach(stat=>{
      tryApplyBuff(hero.buffPool,{stat:stat,value:(battleState.boss[stat+"Stacks"]||0)*0.33,duration:15,offsettable:true});
    });
  }
}

// -------------------- Timeline --------------------
function logRound(){
  const snapshot = {round:battleState.round, boss:{...battleState.boss}, heroes:[]};
  battleState.heroes.forEach(h=>{
    const buffsSummary = {};
    for(const stat in h.buffPool){
      buffsSummary[stat]=h.buffPool[stat].map(b=>`${(b.value*100).toFixed(1)}% (${b.duration})`);
    }
    snapshot.heroes.push({name:h.name, energy:h.energy, buffs:buffsSummary});
  });
  battleState.timeline.push(snapshot);
}

function renderTimeline(){
  const pre=document.getElementById("timeline");
  pre.textContent=battleState.timeline.map(r=>{
    const heroLines = r.heroes.map(h=>{
      const buffStr = Object.entries(h.buffs).map(([k,v])=>`${k}: ${v.join(", ")}`).join("; ");
      return `${h.name} | Energy: ${h.energy} | Buffs: ${buffStr||"none"}`;
    }).join("\n");
    return `Round ${r.round} | Abyssal Corruption: ${r.boss.abyssalCorruption}\n${heroLines}`;
  }).join("\n\n");
}

// -------------------- Simulation --------------------
function startSimulation(){
  battleState.heroes=[];
  battleState.timeline=[];
  const heroSelects=document.querySelectorAll(".heroSelect");
  const artifactSelects=document.querySelectorAll(".artifactSelect");

  for(let i=0;i<6;i++){
    const heroName=heroSelects[i].value;
    if(!heroName) continue;
    const hero={...heroTemplates[heroName], artifact:artifactSelects[i].value, buffPool:{}, energy:50};
    if(hero.artifact==="db") hero.energy+=50;
    if(hero.artifact==="mirror") hero.energy+=75;
    battleState.heroes.push(hero);
  }

  for(battleState.round=1;battleState.round<=15;battleState.round++){
    applyIslandStartRound();
    battleState.heroes.forEach(h=>{
      const actionType=h.energy>=100?"active":"basic";
      applyHeroAction(h,actionType);
    });
    seBossNormalAttack();
    bossEndOfRound();
    applyIslandEndRound();
    battleState.heroes.forEach(h=>{
      if(h.artifact==="mirror") applyArtifactOnHeroAction(h);
      if(h.artifact==="antlers") applyArtifactOnHeroAction(h);
      decrementBuffs(h.buffPool);
    });
    logRound();
  }

  renderTimeline();
}

// -------------------- Hero Selection UI --------------------
const heroesDiv=document.getElementById("heroes");
for(let i=0;i<6;i++){
  const div=document.createElement("div");
  div.innerHTML=`Hero:
    <select class="heroSelect">
      ${Object.keys(heroTemplates).map(h=>`<option value="${h}">${h}</option>`).join("")}
    </select>
    Artifact:
    <select class="artifactSelect">
      ${artifactOptions.map(a=>`<option value="${a}">${a}</option>`).join("")}
    </select>`;
  heroesDiv.appendChild(div);
}
</script>
</body>
</html>
