
<!DOCTYPE html>
<html>
<head>
    <title>Curse of Decay: Full Restoration & HD Tracking</title>
    <style>
        :root { --bg: #0b0e14; --card: #1a1f2e; --accent: #38bdf8; --text: #cbd5e1; --border: #334155; }
        body { font-family: 'Consolas', monospace; background: var(--bg); color: var(--text); padding: 20px; font-size: 12px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 20px; }
        .card { background: var(--card); border: 1px solid var(--border); padding: 12px; border-radius: 4px; }
        .card h3 { margin: 0 0 8px 0; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom:4px; }
        input, select { background: #000; color: #fff; border: 1px solid var(--border); padding: 4px; width: 100%; margin: 4px 0; box-sizing:border-box; }
        label { display:block; margin: 3px 0; }
        button { padding: 15px; font-weight: bold; cursor: pointer; border: 1px solid var(--accent); background: transparent; color: var(--accent); margin-top: 10px; width: 100%; }
        button:hover { background: var(--accent); color: #000; }
        #output { background: #000; border: 1px solid var(--border); padding: 15px; height: 600px; overflow-y: auto; line-height: 1.5; margin-top: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 11px; }
        th, td { border: 1px solid var(--border); padding: 6px; text-align: left; }
        th { background: #111; color: var(--accent); }
        small { color: #64748b; }
    </style>
</head>
<body>

<div class="grid" id="hero-inputs"></div>

<div class="card" style="margin-bottom:12px;">
    <h3>üëÅÔ∏è Pupil ‚Äî 3 Lowest HP Heroes</h3>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <div style="flex:1"><label>Lowest HP #1</label><select id="lowhp0"><option value="">-- None --</option></select></div>
        <div style="flex:1"><label>Lowest HP #2</label><select id="lowhp1"><option value="">-- None --</option></select></div>
        <div style="flex:1"><label>Lowest HP #3</label><select id="lowhp2"><option value="">-- None --</option></select></div>
    </div>
    <small style="margin-top:4px;display:block;">Every 4 Pupil-wearer actions ‚Üí these 3 heroes get 100% boss-active dodge for 2 rounds.</small>
</div>

<div class="card" style="margin-bottom:20px;">
    <h3>Environment Controls</h3>
    <div style="display:flex; gap:20px;">
        <div style="flex:1"><label>Global Star Imprint</label>
            <select id="gImp"><option value="none">None</option><option value="foresight" selected>Foresight</option><option value="destiny">Destiny</option></select>
        </div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl8" checked> Island 8 (+3% allDmg per ally active)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl9" checked> Island 9 (allDmgReduction decay + HD ramp)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl10" checked> Island 10 (+25% allDmg all at round start)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl11" checked> Island 11 (Soul Protection ‚Äî random CC immunity)</label></div>
    </div>
</div>

<button onclick="sim(false)">Simulate 15-Round Battle (Full Log)</button>
<button onclick="sim(true)">Statistical Batch (1000 Fights Summary)</button>
<div id="output"></div>

<script>
const HEROES = ["LFA","SQH","STV","BDSM","LBRM","ELY","HW"];
const ARTS   = ["None","Demon Bell","Spiritual Mirror","Antlers","Scissors"];
const defaults = [
    { h:"BDSM", a:"Demon Bell", s:2000, ci:120 },
    { h:"SQH",  a:"Spiritual Mirror", s:1900, ci:110 },
    { h:"LFA",  a:"Antlers",   s:1500, ci:200 },
    { h:"HW",   a:"Scissors",  s:1800, ci:80  },
    { h:"ELY",  a:"Scissors",  s:1700, ci:120 },
    { h:"STV",  a:"Scissors",  s:1600, ci:200 }
];

const container = document.getElementById('hero-inputs');
defaults.forEach((d, i) => {
    container.innerHTML += `<div class="card">
        <h3>POS ${i+1}</h3>
        <select id="h${i}">${HEROES.map(h=>`<option value="${h}" ${h===d.h?'selected':''}>${h}</option>`).join('')}</select>
        <select id="a${i}">${ARTS.map(a=>`<option value="${a}" ${a===d.a?'selected':''}>${a}</option>`).join('')}</select>
        <div style="display:flex;gap:5px;">
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">SPD</label>
                <input type="number" id="s${i}"  value="${d.s}"  placeholder="SPD" style="width:100%">
            </div>
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">CI %</label>
                <input type="number" id="ci${i}" value="${d.ci}" placeholder="CI%" style="width:100%">
            </div>
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">Dodge %</label>
                <input type="number" id="dg${i}" value="0" min="0" max="100" placeholder="Dodge%" style="width:100%">
            </div>
        </div>
        <label><input type="checkbox" id="spec${i}"> Soul Specter</label>
        <label><input type="checkbox" id="pupil${i}"> Pupil</label>
        <label><input type="checkbox" id="nova${i}"> Nova</label>
        <label><input type="radio" name="max" value="${i}" ${i===0?'checked':''}> Max ATK</label>
    </div>`;
});

function refreshLowHPDropdowns() {
    for (let s = 0; s < 3; s++) {
        let sel = document.getElementById(`lowhp${s}`);
        let cur = sel.value;
        sel.innerHTML = '<option value="">-- None --</option>';
        for (let i = 0; i < 6; i++) {
            let name = document.getElementById(`h${i}`).value;
            sel.innerHTML += `<option value="${i}" ${cur==i?'selected':''}>${name} (POS ${i+1})</option>`;
        }
    }
}
window.addEventListener('load', () => {
    ['lowhp0','lowhp1','lowhp2'].forEach((id, i) => {
        let sel = document.getElementById(id);
        if (sel) sel.value = String(3 + i);
    });
    refreshLowHPDropdowns();
    for (let i = 0; i < 6; i++) document.getElementById(`h${i}`).addEventListener('change', refreshLowHPDropdowns);
});

let units = [], boss = {}, silent = false, bossHDStacks = 0;

function log(msg, color="#fff") {
    if (!silent) document.getElementById('output').innerHTML += `<div style="color:${color}">${msg}</div>`;
}

function checkC(u, type, amount="") {
    if (u.curse > 0) {
        u.curse--;
        log(`&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${u.name}: ${type} ${amount}`, "#fbbf24");
        return false;
    }
    log(`&nbsp;&nbsp;&nbsp;‚úÖ [BUFF LANDED] ${u.name}: ${type} ${amount}`, "#4ade80");
    return true;
}

function addBuff(u, type, value, rounds, source) {
    u.buffs[type].push({ value, rounds, source });
    let total = getBuffTotal(u, type);
    let extraInfo = (type === "ci") ? ` | Effective CI: ${((u.baseCI + total)*100).toFixed(0)}%` : "";
    log(`&nbsp;&nbsp;&nbsp;üìä [BUFF] ${u.name} +${(value*100).toFixed(0)}% ${type.toUpperCase()} (${rounds}r) from ${source} | Total ${type.toUpperCase()}: +${(total*100).toFixed(0)}%${extraInfo}`, "#34d399");
}
// Like addBuff but no log ‚Äî used when caller logs a grouped summary instead
function addBuffSilent(u, type, value, rounds, source) {
    u.buffs[type].push({ value, rounds, source });
}
// Refresh semantics: remove all existing stacks from same source, then add fresh one.
// Use for short-duration buffs that reapply (prevents unbounded stacking).
function refreshBuff(u, type, value, rounds, source) {
    u.buffs[type] = u.buffs[type].filter(b => b.source !== source);
    addBuff(u, type, value, rounds, source);
}
// Silent version of refreshBuff (for batch/grouped logging)
function refreshBuffSilent(u, type, value, rounds, source) {
    u.buffs[type] = u.buffs[type].filter(b => b.source !== source);
    u.buffs[type].push({ value, rounds, source });
}

function getBuffTotal(u, type) {
    return u.buffs[type].reduce((sum, b) => sum + b.value, 0);
}

function tickBuffs(u) {
    const types = Object.keys(u.buffs);
    types.forEach(type => {
        let expired = [];
        u.buffs[type] = u.buffs[type]
            .map(b => ({ ...b, rounds: b.rounds - 1 }))
            .filter(b => {
                if (b.rounds <= 0) { expired.push(b); return false; }
                return true;
            });
        if (expired.length === 0) return;
        // Group by (value, source-prefix) to collapse repeated ticks
        let groups = {};
        expired.forEach(b => {
            let key = `${(b.value*100).toFixed(0)}%|${b.source.replace(/ tick \d+$/, " tick N")}`;
            if (!groups[key]) groups[key] = { b, count: 0 };
            groups[key].count++;
        });
        Object.values(groups).forEach(({ b, count }) => {
            let label = b.source.replace(/ tick \d+$/, " ticks");
            let countStr = count > 1 ? ` √ó${count}` : "";
            log(`&nbsp;&nbsp;&nbsp;‚è±Ô∏è [BUFF EXPIRED] ${u.name} ${type.toUpperCase()} +${(b.value*100).toFixed(0)}%${countStr} (${label})`, "#64748b");
        });
    });
}

function tryBuff(u, type, value, rounds, source) {
    if (u.curse > 0) {
        u.curse--;
        log(`&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${u.name}: ${source} ${type.toUpperCase()} +${(value*100).toFixed(0)}%`, "#fbbf24");
        return false;
    }
    addBuff(u, type, value, rounds, source);
    return true;
}

function trackStat(u, key, value) {
    u.stats[key] = (u.stats[key] || 0) + value;
}

function trigCal(u) {
    if (u.calamity >= 5) {
        let effectiveCI = u.baseCI + getBuffTotal(u, "ci");
        let p = Math.max(0, 2.0 - effectiveCI); // p=0 at CI‚â•200%, p=1 at CI=100%
        log(`&nbsp;&nbsp;&nbsp;üí† [CI CHECK] ${u.name} effectiveCI=${(effectiveCI*100).toFixed(0)}% (base ${(u.baseCI*100).toFixed(0)}% + buffs +${(getBuffTotal(u,"ci")*100).toFixed(0)}%) ‚Üí CC chance ${(p*100).toFixed(0)}%`, "#38bdf8");
        ["silence","fear","seal"].forEach(t => {
            if (u.imm !== t && Math.random() < p) {
                u.cc[t] = 2;
                log(`&nbsp;&nbsp;&nbsp;üõë [CC APPLIED] ${u.name} is ${t.toUpperCase()}ED!`, "#ef4444");
                if (t === "fear") {
                    bossHDStacks++;
                    boss.holyDmg = (boss.holyDmg || 0) + 0.125;
                    log(`&nbsp;&nbsp;&nbsp;üìà [BOSS HD] Fear on ${u.name} ‚Üí +12.5% Holy Dmg | Total: ${bossHDStacks} stacks (+${(bossHDStacks*12.5).toFixed(1)}%)`, "#38bdf8");
                }
            }
        });
        u.calamity = 0;
    }
}

function grantFG(target, bdsm) {
    let isNew = !target.franticGluttony;
    target.franticGluttony = true;
    target.franticGluttonyRounds = 2;
    log(`&nbsp;&nbsp;&nbsp;üå∏ [FRANTIC GLUTTONY] ${target.name} gains FG (${isNew ? 'new' : 'refreshed'})`, "#ec4899");
    if (isNew) {
        addBuff(target, "atk", 0.15, 999, "Frantic Gluttony");
        addBuff(target, "spd", 0.20, 999, "Frantic Gluttony SPD");
    }
    const ccList = ["silence","fear","seal"];
    let active = ccList.filter(t => target.cc[t] > 0);
    if (active.length > 0) {
        let pick = active[Math.floor(Math.random() * active.length)];
        target.cc[pick] = 0;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è [BDSM DEEP SUB] ${target.name}: ${pick.toUpperCase()} cleansed via FG grant`, "#a78bfa");
    }
    if (isNew) {
        addBuff(target, "drOffset", 0.20, 999, "FG ‚â•40% Shield DR Offset");
        addBuff(target, "allDmg",   0.10, 999, "FG ‚â•40% Shield All Dmg");
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [FG ‚â•40%+‚â•50% SHIELD] ${target.name}: +20% DR Offset (direct) + 10% All Dmg (direct)`, "#ec4899");
    }
}

function triggerBoundlessSepal(bdsm) {
    if (bdsm.boundlessTriggers >= 3) return;
    bdsm.boundlessTriggers++;
    log(`&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS SEPAL] Trigger ${bdsm.boundlessTriggers}/3: granting Shield to 3 random allies`, "#ec4899");
    let allies = units.filter(a => a !== bdsm);
    let shuffled = allies.sort(() => Math.random() - 0.5).slice(0, 3);
    shuffled.forEach(a => {
        a.shield = Math.min(100, (a.shield || 0) + 500);
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ ${a.name} gains Shield (500% ATK)`, "#ec4899");
    });
    if (bdsm.boundlessTriggers >= 3) {
        log(`&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS SEPAL] Limit reached!`, "#ec4899");
        if (Math.random() < 0.60) {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ Boss STUNNED for 2 rounds (60% proc)`, "#ec4899");
            boss.stunned = (boss.stunned || 0) + 2;
        }
        boss.ciDebuff = (boss.ciDebuff || 0) + 0.10;
        boss.ciDebuffRounds = 2;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS DEEP SUB] Boss back-line CI -10% for 2 rounds`, "#ec4899");
        units.forEach(a => {
            a.hp = Math.min(100, a.hp + 6);
            addBuff(a, "atk", 0.06, 3, "Boundless Noble Sub");
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS NOBLE SUB] ${a.name} +6% HP, +6% ATK (3r)`, "#ec4899");
        });
    }
}

function applyLI(source) {
    boss.lethalIncense = true;
    boss.lethalIncenseRounds = 2;
    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Lethal Incense III applied to boss (2 rounds) by ${source}`, "#a78bfa");
}

function applyVoM(target, source) {
    if (!target.veilOfMist) {
        target.veilOfMist = true;
        target.veilOfMistRounds = 2;
        log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Veil of Mist applied to ${target.name} by ${source}`, "#a78bfa");
    }
}

function grantSM(units) {
    let smTarget = units.find(u => u.isM);
    if (!smTarget) return;
    let isRepeat = smTarget.stygianMark;
    smTarget.stygianMark = true;
    if (isRepeat && smTarget.stygianMarkStack < 2) smTarget.stygianMarkStack++;
    else if (!isRepeat) smTarget.stygianMarkStack = 1;
    let bonus = smTarget.stygianMarkStack * 0.10;
    smTarget.buffs.allDmg = smTarget.buffs.allDmg.filter(b => b.source !== "Stygian Mark");
    addBuff(smTarget, "allDmg", bonus, 1, "Stygian Mark");
    log(`&nbsp;&nbsp;&nbsp;üåÄ [FAINT FRAGRANCE] Stygian Mark granted to ${smTarget.name} (stack ${smTarget.stygianMarkStack}: +${(bonus*100).toFixed(0)}% allDmg, 1r)`, "#a78bfa");
}

function expireLI(stv) {
    if (!boss.lethalIncense) return;
    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV LI EXPIRY] Lethal Incense III expires on boss`, "#a78bfa");
    boss.lethalIncense = false;
    if (boss.energy >= 100) {
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ Boss had ‚â•100 energy: loses 100 energy`, "#a78bfa");
        if (Math.random() < 0.5) {
            let candidates = units.filter(u => !u.lethalIncense);
            if (candidates.length > 0) {
                let target = candidates[Math.floor(Math.random() * candidates.length)];
                target.lethalIncense = true;
                target.lethalIncenseRounds = 2;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [LI SPREAD] Lethal Incense spread to ${target.name} (ally) for 2 rounds`, "#a78bfa");
            }
        }
    } else {
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ Boss had <100 energy: takes 30% Max HP damage (capped at 1500% STV ATK)`, "#a78bfa");
        trackStat(stv, "damageDealt", 1500);
    }
}

function triggerFF(actor, stv) {
    if (!actor.stygianMark) return;
    trackStat(stv, "damageDealt", 1500);
    log(`&nbsp;&nbsp;&nbsp;üåÄ [FAINT FRAGRANCE] ${actor.name} (SM) acts ‚Üí LI attack: 1500% ATK cap damage`, "#a78bfa");
    applyLI("Faint Fragrance");
    let lowest = units.reduce((a, b) => a.hp < b.hp ? a : b);
    let heal = (100 - lowest.hp) * 0.15;
    lowest.hp = Math.min(100, lowest.hp + heal);
    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FF] ${lowest.name} +${heal.toFixed(1)}% lost HP restored (now ${lowest.hp.toFixed(1)}%)`, "#a78bfa");
    if (Math.random() < 0.70) {
        boss.stunned = (boss.stunned || 0) + 2;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FF DEEP SUB] Boss STUNNED 2 rounds (70% proc)`, "#a78bfa");
    }
    lowest.shield = Math.min(100, (lowest.shield || 0) + 1000);
    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FF NOBLE SUB] ${lowest.name} gains Shield (1000% ATK)`, "#a78bfa");
}

function tryStarSoul(u) {
    if (!u.hasS) return;
    let triggered = Math.random() < 0.333;
    u.starSoulTally++;
    if (u.starSoulTally >= 3) {
        triggered = true;
        u.starSoulTally = 0;
        log(`&nbsp;&nbsp;&nbsp;üí• [STAR SOUL BURST] ${u.name} guaranteed burst!`, "#f472b6");
    }
    if (triggered) {
        let fastest = units.reduce((a,b) => b.spd > a.spd ? b : a);
        log(`&nbsp;&nbsp;&nbsp;‚≠ê [STAR SOUL SKILL] ${u.name}: +100 to ${fastest.name} (highest SPD), +50 to self`, "#f472b6");
        if (checkC(fastest, "Star Soul +100 Energy", "+100")) fastest.energy += 100;
        if (checkC(u, "Star Soul Self +50", "+50")) u.energy += 50;
    }
}

function triggerPupil(actor) {
    if (!actor.hasPupil) return;
    let maxAtkHero = units.find(u => u.isM) || actor;
    if (checkC(maxAtkHero, "Pupil Dodge +22%")) {
        maxAtkHero.dodge = Math.min(1, maxAtkHero.dodge + 0.22);
        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${maxAtkHero.name} (Max ATK) Dodge +22% (curse-offsettable, resets EoR)`, "#e879f9");
    }
    actor.pupilActionCount++;
    log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${actor.name} action count: ${actor.pupilActionCount}/4`, "#e879f9");
    if (actor.pupilActionCount >= 4) {
        actor.pupilActionCount = 0;
        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL BURST] 4-action threshold! Granting 100% dodge (2 rounds) to low-HP heroes`, "#e879f9");
        units.filter(u => u.isLowHP).forEach(u => {
            u.pupilDodgeRounds = 2;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ‚Üí ${u.name} has 100% dodge for 2 rounds`, "#e879f9");
        });
    }
}

function triggerNova(u) {
    if (!u.hasNova) return;
    u.novaActionCount++;
    log(`&nbsp;&nbsp;&nbsp;üí´ [NOVA] ${u.name} action count: ${u.novaActionCount}/4`, "#fcd34d");
    if (u.novaActionCount >= 4) {
        u.novaActionCount = 0;
        u.energy += 100;
        log(`&nbsp;&nbsp;&nbsp;üí´ [NOVA BURST] ${u.name} +100 Energy (direct)! (now ${u.energy})`, "#fcd34d");
    }
}

function runOne() {
    const imp  = document.getElementById('gImp').value;
    const is9  = document.getElementById('isl9').checked;
    const is11 = document.getElementById('isl11').checked;
    const is8  = document.getElementById('isl8').checked;
    const is10 = document.getElementById('isl10').checked;
    const mIdx = parseInt(document.querySelector('input[name="max"]:checked').value);

    bossHDStacks = 0;
    units = [];
    let isl9HDStacks = 0;
    let isl9DRStacks = 6;

    for (let i = 0; i < 6; i++) {
        let art = document.getElementById(`a${i}`).value;
        units.push({
            pos: i+1,
            name: document.getElementById(`h${i}`).value,
            energy: (art === "Demon Bell" || art === "Spiritual Mirror") ? 100 : 50,
            curse: 0, calamity: 0, trans: 0, acts: 0, turnsLost: 0,
            cc: { silence:0, fear:0, seal:0 },
            imm: is11 ? ["silence","fear","seal"][Math.floor(Math.random()*3)] : "none",
            art: art,
            spd: parseInt(document.getElementById(`s${i}`).value),
            baseCI: parseInt(document.getElementById(`ci${i}`).value) / 100,
            hasS: document.getElementById(`spec${i}`).checked,
            hasPupil: document.getElementById(`pupil${i}`).checked,
            isM: (i === mIdx), isFr: (i < 2), bDone: false,
            dodge: (parseInt(document.getElementById(`dg${i}`).value) || 0) / 100,
            baseDodge: (parseInt(document.getElementById(`dg${i}`).value) || 0) / 100,
            starSoulTally: 0,
            pupilActionCount: 0,
            pupilDodgeRounds: 0,
            hasNova: document.getElementById(`nova${i}`).checked,
            novaActionCount: 0,
            isLowHP: false,
            lbrmSlot1: (i === 0),
            franticGluttony: false,
            franticGluttonyRounds: 0,
            shield: 0,
            infuseUsed: false,
            boundlessTriggers: 0,
            hp: 100,
            stygianMark: false,
            stygianMarkStack: 0,
            lethalIncense: false,
            lethalIncenseRounds: 0,
            veilOfMist: false,
            veilOfMistRounds: 0,
            fearAbyssalGaze: false,
            fearAbyssalGazeRounds: 0,
            sourceOfFearProcs: 0,
            powerOfDream: 0,
            dreamMagicWings: false,
            dreamMagicMagnification: false,
            dreamMagicProtection: false,
            mirrorMagicWings: false,
            mirrorMagicMagnification: false,
            mirrorMagicProtection: false,
            shieldLostThisRound: false,
            beeSugarCoat: false,
            fictionalMagic: false,
            fictionalMagicRounds: 0,
            mirrorMagicCount: 3,
            buffs: { atk:[], dr:[], ci:[], spd:[], hd:[], cd:[], crit:[], armor:[], allDmg:[], allDmgReduction:[], drOffset:[] },
            stats: { damageDealt: 0, healingDone: 0 }
        });
    }

    boss = { abyssalCorruption: 0, bleed: [], spdDebuff: 0, spiritMirrorRound: 0, atkDebuff: 0, atkDebuffRounds: 0, armorDebuff: 0, armorDebuffRounds: 0, lethalIncense: false, lethalIncenseRounds: 0, veilOfMist: false, veilOfMistRounds: 0, healReduction: 0, healReductionRounds: 0, atkSteal: 0, atkStealRounds: 0 };

    for (let s = 0; s < 3; s++) {
        let val = document.getElementById(`lowhp${s}`).value;
        if (val !== "" && units[parseInt(val)]) units[parseInt(val)].isLowHP = true;
    }
    let lowHPNames = units.filter(u => u.isLowHP).map(u => u.name).join(", ");
    let pupilWearers = units.filter(u => u.hasPupil).map(u => u.name).join(", ");
    log(`üëÅÔ∏è PUPIL wearers: ${pupilWearers || "none"} | Low-HP targets: ${lowHPNames || "none"}`, "#e879f9");

    units.filter(u => u.name === "LBRM").forEach(lbrm => {
        lbrm.mirrorMagicWings = true;
        lbrm.mirrorMagicMagnification = true;
        lbrm.mirrorMagicProtection = true;
        lbrm.mirrorMagicCount = 3;
        lbrm.mirrorMagicWingsUsed = false;
        addBuff(lbrm, "ci",     0.08, 999, "Mirror Magic Wings CI");
        addBuff(lbrm, "spd",    0.08, 999, "Mirror Magic Wings SPD");
        addBuff(lbrm, "allDmg", 0.10, 999, "Mirror Magic Magnification allDmg");
        addBuff(lbrm, "dr",     0.18, 999, "Mirror Magic Deep Sub DR (3√ó6%)");
        log(`[LBRM INIT] Dreamlike Illusion: 3 Mirror Magic (+8%CI +8%SPD +10%allDmg +18%DR)`, "#f0abfc");
    });

    units.forEach(u => {
        if (u.name === "SQH") {
            log(`üëë [SQH ROYAL GUARD] Granting +24% All-Damage to all allies at battle start`, "#f59e0b");
            units.filter(a => a !== u).forEach(a => {
                addBuff(a, "allDmg", 0.24, 999, "SQH Royal Guard");
            });
        }
    });

    units.forEach(u => {
        if (u.hasS) {
            log(`üîÆ ${u.name} Specter Battle-Start`);
            if (checkC(u, "Spec Start Self", "+50")) u.energy += 50;
            let randAlly = units[Math.floor(Math.random() * units.length)];
            if (checkC(randAlly, "Spec Start Team", "+50")) randAlly.energy += 50;
        }
    });

    for (let r = 1; r <= 15; r++) {
        log(`ROUND ${r}`, "#ff4757");

        units.forEach(u => { if (u.pupilDodgeRounds > 0) u.pupilDodgeRounds--; });

        if (is9) {
            if (isl9DRStacks > 0) {
                isl9DRStacks--;
                units.forEach(u => {
                    let idx = u.buffs.allDmgReduction.findIndex(b => b.source === "Island 9 DR start" || b.source === "Island 9 DR");
                    if (idx >= 0) u.buffs.allDmgReduction.splice(idx, 1);
                    addBuffSilent(u, "allDmgReduction", isl9DRStacks * 0.10, 999, "Island 9 DR");
                });
                log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL9] allDmgReduction now ${(isl9DRStacks*10)}% (all allies)`, "#a78bfa");
            }
            isl9HDStacks++;
            log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL9] Holy Dmg now ${(isl9HDStacks*10)}%`, "#a78bfa");
        }
        if (is10) {
            units.forEach(u => addBuffSilent(u, "allDmg", 0.25, 2, "Island 10"));
            log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL10] All allies +25% allDmg (2r, silent)`, "#a78bfa");
        }

        let lbrmHero = units.find(x => x.name === "LBRM" && x.cc.seal <= 0);
        if (lbrmHero) {
            units.forEach(ally => {
                if (ally.hp < 30 && lbrmHero.energy >= 30) {
                    lbrmHero.energy -= 30;
                    lbrmHero.powerOfDream = Math.min(3, lbrmHero.powerOfDream + 1);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON] ${ally.name} HP<30% ‚Üí Shield 2000% ATK granted, LBRM PoD=${lbrmHero.powerOfDream}`, "#f0abfc");
                }
            });
        }

        let stv = units.find(u => u.name === "STV");
        if (stv) grantSM(units);

        units.forEach(u => {
            u.infuseUsed = false;
            u.boundlessTriggers = 0;
            if (u.franticGluttony) {
                u.franticGluttonyRounds--;
                if (u.franticGluttonyRounds <= 0) {
                    u.franticGluttony = false;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] ${u.name} Frantic Gluttony expired`, "#ec4899");
                }
            }
        });

        units.forEach(u => {
            if (u.energy >= 100) checkC(u, "Round Start ATK Buff (Energy ‚â•100)", "+30%");
        });

        units.forEach(u => {
            u.bDone = false;
            if (u.name === "STV") {
                if (u.trans >= 12) {
                    u.trans -= 12;
                    log(`&nbsp;&nbsp;&nbsp;üíé [STV MOON ABYSS 12-STACK]`, "#a78bfa");
                    trackStat(u, "damageDealt", 1500);
                    applyLI("STV Moon Abyss 12-stack");
                    boss.atkDebuff = (boss.atkDebuff || 0) + 0.20; boss.atkDebuffRounds = 2;
                    boss.armorDebuff = (boss.armorDebuff || 0) + 0.20; boss.armorDebuffRounds = 2;
                    boss.drDebuff = (boss.drDebuff || 0) + 0.20; boss.drDebuffRounds = 2;
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.20; boss.ciDebuffRounds = 2;
                    boss.spdDebuff = (boss.spdDebuff || 0) + 100;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV 12-STACK] Boss: -20% ATK/Armor/DR/CI, -100 SPD (2r)`, "#a78bfa");
                    units.forEach(a => {
                        let bonus = a.stygianMark ? 0.20 : 0.10;
                        addBuff(a, "allDmg", bonus, 2, "STV Moon Abyss 12-stack");
                    });
                    let smAlly = units.find(a => a.isM);
                    if (smAlly) addBuff(smAlly, "allDmg", 0.10, 2, "STV Acheron Barque");
                    boss.healReduction = 0.80; boss.healReductionRounds = 3;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduced 80% for 3 rounds`, "#a78bfa");
                    addBuff(u, "allDmg", 0.15, 2, "STV Sun Halo");
                    units.forEach(a => { if (checkC(a, "STV Glowed Glory +20", "+20")) a.energy += 20; });
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV GLOWED GLORY] +20 Energy to all (curse-offsettable)`, "#a78bfa");
                } else if (u.trans >= 6) {
                    u.trans -= 6;
                    log(`&nbsp;&nbsp;&nbsp;üíé [STV 6-STACK TRANSITION]`, "#a78bfa");
                    trackStat(u, "damageDealt", 1500);
                    applyLI("STV 6-stack");
                    let smAlly = units.find(a => a.isM);
                    if (smAlly) addBuff(smAlly, "allDmg", 0.10, 2, "STV Acheron Barque");
                    boss.healReduction = 0.80; boss.healReductionRounds = 3;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduced 80% for 3 rounds`, "#a78bfa");
                    addBuff(u, "allDmg", 0.15, 2, "STV Sun Halo");
                    units.forEach(a => { if (checkC(a, "STV Glowed Glory +20", "+20")) a.energy += 20; });
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV GLOWED GLORY] +20 Energy to all (curse-offsettable)`, "#a78bfa");
                }
            }
        });

        let ord = [...units].sort((a,b) => b.spd - a.spd);
        ord.forEach(u => {
            let sealed = u.cc.seal > 0;
            let silenced = u.cc.silence > 0;
            log(`--- ${u.name} Moves (Nrg: ${u.energy}, Dodge: ${Math.round(u.dodge*100)}%) ---`);

            if (u.cc.fear > 0 || u.cc.silence > 0 || u.cc.seal > 0) {
                log(`&nbsp;&nbsp;&nbsp;‚ö†Ô∏è CC ACTIVE: ${u.cc.fear>0?'FEAR ':''}${u.cc.silence>0?'SILENCE ':''}${u.cc.seal>0?'SEAL':''}`, "#ef4444");
            }

            if (u.name === "BDSM" && u.energy >= 100 && !u.bDone && !silenced) {
                log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è [BDSM THRESHOLD] Backline CI +15% (2r)`, "#ec4899");
                units.forEach(t => {
                    if (!t.isFr) {
                        if (t.curse > 0) {
                            t.curse--;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${t.name}: BDSM Threshold CI +15%`, "#fbbf24");
                        } else {
                            refreshBuff(t, "ci", 0.15, 2, "BDSM Threshold CI");
                        }
                    }
                });
                u.bDone = true;
            }

            let didHitBoss = false;
            let usedBasic = false;
            let usedActive = false;

            if (u.energy >= 100 && u.cc.silence <= 0) {
                u.energy = 0; u.trans += 6; u.acts++; didHitBoss = true; usedActive = true;
                log(`üî• ACTION: Active`);

                units.forEach(target => {
                    if (target.name === "BDSM" && u.name !== "BDSM" && target.cc.silence <= 0) {
                        if (checkC(target, "BDSM Passive Energy", "+3")) target.energy += 3;
                        if (u.franticGluttony) {
                            let lostHp = 100 - target.hp;
                            let heal = lostHp * 0.10;
                            target.hp = Math.min(100, target.hp + heal);
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [FG TRIGGER] ${u.name} acted with FG ‚Üí BDSM +${heal.toFixed(1)}% HP (now ${target.hp.toFixed(1)}%)`, "#ec4899");
                            triggerBoundlessSepal(target);
                        }
                    }
                });
                { let stvHero = units.find(s => s.name === "STV");
                  if (stvHero && u.stygianMark && u.name !== "STV") triggerFF(u, stvHero); }
                if (u.name === "STV") {
                    trackStat(u, "damageDealt", 1500);
                    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV SOULCALL] 1500% ATK damage dealt`, "#a78bfa");
                    applyLI("Soulcall");
                    boss.spdDebuff = (boss.spdDebuff || 0) + 50; boss.spdDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV DEEP SUB] Boss SPD -50 (2r)`, "#a78bfa");
                    boss.atkDebuff = (boss.atkDebuff || 0) + 0.20; boss.atkDebuffRounds = 2;
                    boss.armorDebuff = (boss.armorDebuff || 0) + 0.20; boss.armorDebuffRounds = 2;
                    boss.drDebuff = (boss.drDebuff || 0) + 0.20; boss.drDebuffRounds = 2;
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.20; boss.ciDebuffRounds = 2;
                    boss.spdDebuff = (boss.spdDebuff || 0) + 100;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV SOULCALL] Boss: -20% ATK/Armor/DR/CI, -100 SPD (2r)`, "#a78bfa");
                    units.forEach(a => {
                        let isSM = a.stygianMark;
                        let mult = isSM ? 2 : 1;
                        tryBuff(a, "atk",   0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "dr",    0.10 * mult, 2, "STV Soulcall");
                        refreshBuff(a, "ci", 0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "armor", 0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "spd",   (isSM ? 0.60 : 0.30), 2, "STV Soulcall SPD");
                        if (isSM) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [SM BONUS] ${a.name} gets 2√ó buffs from Soulcall`, "#a78bfa");
                    });
                    triggerFF(u, u);
                }
                if (u.name === "SQH") {
                    let dmg = 1800;
                    trackStat(u, "damageDealt", dmg);
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] ${dmg}% ATK damage dealt`, "#f59e0b");
                    boss.bleed.push({ dmg: 1800, rounds: 2 });
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] Bleed applied (1800% ATK/round for 2 rounds)`, "#f59e0b");
                    boss.abyssalCorruption++;
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] Abyssal Corruption: ${boss.abyssalCorruption} layer(s) | Boss takes +${(boss.abyssalCorruption*24).toFixed(0)}% Crit DMG`, "#f59e0b");
                    if (Math.random() < 0.25) {
                        boss.abyssalCorruption++;
                        log(`&nbsp;&nbsp;&nbsp;üëë [SQH NOBLE SUB] Extra Corruption layer! Total: ${boss.abyssalCorruption} | Boss takes +${(boss.abyssalCorruption*24).toFixed(0)}% Crit DMG`, "#f59e0b");
                    }
                }
                if (u.name === "BDSM") {
                    trackStat(u, "damageDealt", 3000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM TIME TO FEAST] 3000% ATK damage dealt`, "#ec4899");
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.15;
                    boss.ciDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Boss CI -15% for 2 rounds`, "#ec4899");
                    u.hp = Math.min(100, u.hp + 25);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Self +25% Max HP restored (now ${u.hp}%)`, "#ec4899");
                    triggerBoundlessSepal(u);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Granting Frantic Gluttony to shielded allies`, "#ec4899");
                    units.filter(a => a !== u).forEach(a => { grantFG(a, u); });
                    if (Math.random() < 0.4) {
                        units.forEach(a => { if (checkC(a, "BDSM Active Team Energy", "+10")) a.energy += 10; });
                    }
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM CORE LIBERATION] 5 allies all thresholds met`, "#ec4899");
                    for (let tick = 0; tick < 5; tick++) { units.forEach(a => { trackStat(a, "healingDone", 500); }); }
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•30%] 5 ticks: all allies +2500% ATK healing total`, "#ec4899");
                    // 5 CI ticks ‚Äî refresh (clear old CL CI stacks first, then apply fresh 5)
                    units.forEach(a => {
                        a.buffs.ci = a.buffs.ci.filter(b => !b.source.startsWith("Core Liberation CI"));
                    });
                    for (let tick = 0; tick < 5; tick++) {
                        units.forEach(a => {
                            if (a.curse > 0) { a.curse--; } // curse offsets each tick individually
                            else { addBuffSilent(a, "ci", 0.045, 2, `Core Liberation CI tick ${tick+1}`); }
                        });
                    }
                    units.forEach(a => {
                        let applied = a.buffs.ci.filter(b => b.source.startsWith("Core Liberation CI")).length;
                        let total = getBuffTotal(a, "ci");
                        if (applied > 0) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•40%] ${a.name} +${(applied*4.5).toFixed(1)}% CI (${applied} ticks refreshed, 2r) | Eff. CI: ${((a.baseCI+total)*100).toFixed(0)}%`, "#ec4899");
                    });
                    // 5 allDmg ticks ‚Äî apply silently then log summary per hero
                    for (let tick = 0; tick < 5; tick++) {
                        units.forEach(a => { addBuffSilent(a, "allDmg", 0.045, 2, `Core Liberation allDmg tick ${tick+1}`); });
                    }
                    units.forEach(a => {
                        let applied = a.buffs.allDmg.filter(b => b.source.startsWith("Core Liberation allDmg")).length;
                        let total = getBuffTotal(a, "allDmg");
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•50%] ${a.name} +${(applied*4.5).toFixed(1)}% allDmg (${applied} ticks, 2r) | Total allDmg: +${(total*100).toFixed(0)}%`, "#ec4899");
                    });
                    const bdsmCCTypes = ["silence","fear","seal"];
                    units.forEach(a => {
                        let activeCC = bdsmCCTypes.filter(t => a.cc[t] > 0);
                        if (activeCC.length > 0) {
                            let rem = activeCC[Math.floor(Math.random() * activeCC.length)];
                            a.cc[rem] = 0;
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE CC CLEANSE] ${a.name}: ${rem} removed`, "#ec4899");
                        }
                    });
                    boss.allDmgReductionDebuff = (boss.allDmgReductionDebuff || 0) + 0.10;
                    boss.allDmgReductionDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM NOBLE SUB] Boss All-damage Reduction -10% for 2 rounds`, "#ec4899");
                }
                if (u.name === "LBRM") {
                    let frontline = units.filter(a => a.isFr);
                    trackStat(u, "damageDealt", 2400);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM DREAMLAND DOMINION] 2400% ATK to frontline`, "#f0abfc");
                    let dmDur = 4;
                    frontline.forEach(a => {
                        a.buffs.dr.push({ value: -0.15, rounds: dmDur, source: "DD Frontline DR debuff" });
                        a.buffs.ci.push({ value: -0.15, rounds: dmDur, source: "DD Frontline CI debuff" });
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${a.name} DR -15%, CI -15% (${dmDur}r)`, "#f0abfc");
                    });
                    units.filter(a => !a.isFr).forEach(a => {
                        a.buffs.dr.push({ value: -0.15, rounds: dmDur, source: "DD Backline DR debuff (Deep sub)" });
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD DEEP SUB] ${a.name} DR -15% (${dmDur}r)`, "#f0abfc");
                    });
                    function grantDreamMagic(target, type) {
                        if (type === "Wings"          && target.mirrorMagicWings)         { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Wings ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Magnification"  && target.mirrorMagicMagnification) { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Magnification ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Protection"     && target.mirrorMagicProtection)    { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Protection ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Wings") {
                            target.dreamMagicWings = true;
                            refreshBuff(target, "ci", 0.10, dmDur, "Dream Magic Wings CI");
                            refreshBuff(target, "spd", 0.10, dmDur, "Dream Magic Wings SPD");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Wings (+10%CI, +10%SPD, ${dmDur}r)`, "#f0abfc");
                        }
                        if (type === "Magnification") {
                            target.dreamMagicMagnification = true;
                            addBuff(target, "allDmg", 0.12, dmDur, "Dream Magic Magnification");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Magnification (+12%allDmg, ${dmDur}r)`, "#f0abfc");
                        }
                        if (type === "Protection") {
                            target.dreamMagicProtection = true;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Protection (Shield 3000% ATK, ${dmDur}r)`, "#f0abfc");
                        }
                    }
                    let highestSPD = units.reduce((a, b) => (a.spd > b.spd ? a : b));
                    let highestATK = units.find(u2 => u2.isM) || units[0];
                    let slot1Hero  = units.find(a => a.lbrmSlot1) || units[0];
                    grantDreamMagic(highestSPD, "Wings");
                    grantDreamMagic(highestATK, "Magnification");
                    grantDreamMagic(slot1Hero,  "Protection");
                    u.powerOfDream = 0;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream consumed ‚Üí reset to 0`, "#f0abfc");
                }
                if (u.name === "LFA") {
                    let baseDmg = 2400;
                    trackStat(u, "damageDealt", baseDmg);
                    log(`&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] ${baseDmg}% ATK base damage (2√ó1200%)`, "#c084fc");
                    let extraDmg = 2400;
                    trackStat(u, "damageDealt", extraDmg);
                    trackStat(u, "healingDone", extraDmg * 1.20);
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] Extra ${extraDmg}% ATK (target HP<60%), self heal ${(extraDmg*1.20).toFixed(0)}% ATK`, "#c084fc");
                    let dkmDmg = Math.round((baseDmg + extraDmg) * 1.20);
                    trackStat(u, "damageDealt", dkmDmg - (baseDmg + extraDmg));
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [DKM] Boss immune to fear: +120% extra damage, steal 30% ATK`, "#c084fc");
                    if (checkC(u, "LFA DKM ATK Steal")) {
                        boss.atkSteal = (boss.atkSteal || 0) + 0.30;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [DKM ATK STEAL] -${(boss.atkSteal*100).toFixed(0)}% boss ATK (cumulative, curse-offsettable)`, "#c084fc");
                    }
                }
                if (u.art === "Demon Bell") {
                    units.forEach(a => {
                        if (checkC(a, "DB Energy", "+20")) a.energy += 20;
                        if (Math.random() < 0.5) {
                            if (checkC(a, "DB Bonus", "+10")) a.energy += 10;
                        }
                        if (a.energy >= 100) {
                            tryBuff(a, "spd", 0.09, 4, "Demon Bell Full Energy SPD");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üéµ [DB] ${a.name} at full energy: +9 SPD (4r)`, "#38bdf8");
                        }
                    });
                }
                if ((u.dreamMagicMagnification || u.mirrorMagicMagnification)) {
                    trackStat(u, "damageDealt", 3000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [MAGNIFICATION] ${u.name} extra 15% target Max HP dmg (capped 3000% ATK)`, "#f0abfc");
                }
                if (is8) {
                    units.forEach(a => addBuffSilent(a, "allDmg", 0.03, 999, "Island 8 active proc"));
                    log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL8] ${u.name} active ‚Üí all allies +3% allDmg (permanent, now stacked ${u.acts}√ó)`, "#a78bfa");
                }
                tryStarSoul(u);
                triggerPupil(u);
                triggerNova(u);
                if (u.name === "BDSM" && !u.infuseUsed) {
                    u.infuseUsed = true;
                    if (u.hp >= 70) {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP ‚â•70% (${u.hp.toFixed(1)}%): -60% HP, granting Shield+CI to self & backline`, "#ec4899");
                        u.hp = Math.max(0, u.hp - 60);
                        units.filter(a => !a.isFr || a === u).forEach(a => {
                            a.shield = Math.min(100, (a.shield || 0) + 40);
                            refreshBuff(a, "ci", 0.15, 2, "BDSM Infuse with Flavor");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [INFUSE] ${a.name} Shield +40% MaxHP, CI +15% (2r)`, "#ec4899");
                        });
                        triggerBoundlessSepal(u);
                    } else {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP <70% (${u.hp.toFixed(1)}%): restoring 15% HP + Shield`, "#ec4899");
                        u.hp = Math.min(100, u.hp + 15);
                        u.shield = Math.min(100, (u.shield || 0) + 15);
                        triggerBoundlessSepal(u);
                    }
                }

            } else if (u.cc.fear <= 0) {
                u.energy += 50; didHitBoss = true; usedBasic = true;
                log(`‚öîÔ∏è ACTION: Basic Attack`);
                log(`&nbsp;&nbsp;&nbsp;‚ö° Basic Attack self energy: +50 (direct)`, "#4ade80");

                if (u.franticGluttony && u.name !== "BDSM") {
                    let bdsm = units.find(b => b.name === "BDSM");
                    if (bdsm) {
                        if (checkC(bdsm, "BDSM Passive Energy (FG Basic)", "+3")) bdsm.energy += 3;
                        let lostHp = 100 - bdsm.hp;
                        let heal = lostHp * 0.10;
                        bdsm.hp = Math.min(100, bdsm.hp + heal);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [FG TRIGGER] ${u.name} basic with FG ‚Üí BDSM +${heal.toFixed(1)}% HP (now ${bdsm.hp.toFixed(1)}%)`, "#ec4899");
                        triggerBoundlessSepal(bdsm);
                    }
                }
                if (u.name === "STV") {
                    trackStat(u, "damageDealt", 800);
                    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV FERRYWOMAN] 800% ATK damage dealt`, "#a78bfa");
                    if (Math.random() < 0.80) {
                        boss.veilOfMist = true; boss.veilOfMistRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV BASIC] Boss Veil of Mist applied (2r)`, "#a78bfa");
                    }
                    units.filter(a => a.isFr).forEach(a => {
                        tryBuff(a, "dr", 0.10, 2, "STV Ferrywoman Front");
                        refreshBuff(a, "ci", 0.10, 2, "STV Ferrywoman Front");
                    });
                    units.filter(a => !a.isFr).forEach(a => tryBuff(a, "atk", 0.10, 2, "STV Ferrywoman Back"));
                    if (Math.random() < 0.80) {
                        units.filter(a => !a.isFr).forEach(a => addBuff(a, "allDmg", 0.08, 2, "STV Noble Sub (backline)"));
                        units.filter(a => a.isFr).forEach(a => addBuff(a, "allDmgReduction", 0.08, 2, "STV Noble Sub (frontline)"));
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV NOBLE SUB] Backline +8% allDmg, Frontline +8% allDmgReduction (80% proc)`, "#a78bfa");
                    }
                    if (u.stygianMark) triggerFF(u, u);
                }
                { let stvHero = units.find(s => s.name === "STV");
                  if (stvHero && u.name !== "STV" && u.stygianMark) triggerFF(u, stvHero); }
                if (u.name === "SQH" && !silenced) {
                    tryBuff(u, "crit", 0.18, 4, "SQH Queen's Edict");
                    tryBuff(u, "cd",   0.18, 4, "SQH Queen's Edict");
                    boss.critDebuff = (boss.critDebuff || 0) + 0.25;
                    boss.critDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH QUEEN'S EDICT] Boss Crit -25% for 2 rounds (total: -${(boss.critDebuff*100).toFixed(0)}%)`, "#f59e0b");
                }
                if (u.name === "LBRM" && !silenced) {
                    if (u.powerOfDream >= 2) {
                        if (imp === "foresight") {
                            u.energy += 50;
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream ‚â•2 ‚Üí Dreamland Dominion as basic (Foresight +50 energy)`, "#f0abfc");
                        } else {
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream ‚â•2 ‚Üí Dreamland Dominion fires as basic! (+6 trans)`, "#f0abfc");
                        }
                        u.trans += 6;
                        let frontline2 = units.filter(a => a.isFr);
                        trackStat(u, "damageDealt", 2400);
                        let dmDur2 = 4;
                        frontline2.forEach(a => {
                            a.buffs.dr.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Frontline DR debuff" });
                            a.buffs.ci.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Frontline CI debuff" });
                        });
                        units.filter(a => !a.isFr).forEach(a => {
                            a.buffs.dr.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Backline DR debuff" });
                        });
                        let hs2 = units.reduce((a,b)=>(a.spd>b.spd?a:b));
                        let ha2 = units.find(u2=>u2.isM)||units[0];
                        let s1h2 = units.find(a=>a.lbrmSlot1)||units[0];
                        [[hs2,"Wings"],[ha2,"Magnification"],[s1h2,"Protection"]].forEach(([tgt,type])=>{
                            if(type==="Wings"&&!tgt.mirrorMagicWings){tgt.dreamMagicWings=true;refreshBuff(tgt,"ci",0.10,dmDur2,"Dream Magic Wings CI");refreshBuff(tgt,"spd",0.10,dmDur2,"Dream Magic Wings SPD");}
                            if(type==="Magnification"&&!tgt.mirrorMagicMagnification){tgt.dreamMagicMagnification=true;addBuff(tgt,"allDmg",0.12,dmDur2,"Dream Magic Magnification");}
                            if(type==="Protection"&&!tgt.mirrorMagicProtection){tgt.dreamMagicProtection=true;}
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD(BB)] Dream Magic ${type} ‚Üí ${tgt.name}`, "#f0abfc");
                        });
                        u.powerOfDream = 0;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream consumed ‚Üí 0`, "#f0abfc");
                        usedBasic = true;
                    } else {
                        trackStat(u, "damageDealt", 1200);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM SHADOW] 1200% ATK damage`, "#f0abfc");
                        units.forEach(a => tryBuff(a, "spd", 0.20, 2, "Shadow of Blossom Realm SPD"));
                        let hspd = units.reduce((a,b)=>(a.spd>b.spd?a:b));
                        addBuff(hspd, "drOffset", 0.20, 2, "Shadow CI Offset");
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW] All +20%SPD (2r); ${hspd.name} +20% CI Offset (2r)`, "#f0abfc");
                        if (Math.random() < 0.5) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW DEEP] Boss SPD -10 for 2 rounds (tracked)`, "#f0abfc");
                        if (Math.random() < 0.5) {
                            hspd.energy += 50;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW NOBLE] ${hspd.name} +50 energy (50% proc)`, "#f0abfc");
                        }
                    }
                }
                if (u.name === "LFA" && !silenced) {
                    trackStat(u, "damageDealt", 960);
                    log(`&nbsp;&nbsp;&nbsp;üëø [LFA DEADLY GRASP] 960% ATK damage dealt`, "#c084fc");
                    if (!sealed) {
                        boss.ciDebuff = (boss.ciDebuff || 0) + 0.18;
                        boss.ciDebuffRounds = 3;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA BASIC] Boss CI -18% for 3 rounds (total: -${(boss.ciDebuff*100).toFixed(0)}%)`, "#c084fc");
                        tryBuff(u, "crit", 0.24, 4, "LFA Deadly Grasp");
                        boss.drDebuff = (boss.drDebuff || 0) + 0.05;
                        boss.drDebuffRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA NOBLE SUB] Boss DR -5% for 2 rounds (total: -${(boss.drDebuff*100).toFixed(0)}%)`, "#c084fc");
                    }
                }
                if (u.name === "BDSM" && !silenced) {
                    trackStat(u, "damageDealt", 2000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM RAVENOUS HUNGER] 2000% ATK damage dealt`, "#ec4899");
                    boss.drDebuff = (boss.drDebuff || 0) + 0.10;
                    boss.drDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM BASIC] Boss DR -10% for 2 rounds (total: -${(boss.drDebuff*100).toFixed(0)}%)`, "#ec4899");
                    let lostHp = 100 - u.hp;
                    u.hp = Math.min(100, u.hp + lostHp * 0.20);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM BASIC] Self +${(lostHp*0.20).toFixed(1)}% HP restored (now ${u.hp.toFixed(1)}%)`, "#ec4899");
                    triggerBoundlessSepal(u);
                    if (Math.random() < 0.5) {
                        u.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM NOBLE SUB] +20 Energy (direct)`, "#ec4899");
                    }
                }

                tryStarSoul(u);
                triggerPupil(u);
                triggerNova(u);
                if (u.name === "BDSM" && !u.infuseUsed) {
                    u.infuseUsed = true;
                    if (u.hp >= 70) {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP ‚â•70% (${u.hp.toFixed(1)}%): -60% HP, granting Shield+CI to self & backline`, "#ec4899");
                        u.hp = Math.max(0, u.hp - 60);
                        units.filter(a => !a.isFr || a === u).forEach(a => {
                            a.shield = Math.min(100, (a.shield || 0) + 40);
                            refreshBuff(a, "ci", 0.15, 2, "BDSM Infuse with Flavor");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [INFUSE] ${a.name} Shield +40% MaxHP, CI +15% (2r)`, "#ec4899");
                        });
                        triggerBoundlessSepal(u);
                    } else {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP <70% (${u.hp.toFixed(1)}%): restoring 15% HP + Shield`, "#ec4899");
                        u.hp = Math.min(100, u.hp + 15);
                        u.shield = Math.min(100, (u.shield || 0) + 15);
                        triggerBoundlessSepal(u);
                    }
                }

            } else {
                u.turnsLost++;
                log(`üö´ ACTION: SKIPPED (${u.cc.fear > 0 ? "Fear" : u.cc.silence > 0 ? "Silence+NoEnergy" : "Unknown"})`, "#ef4444");
            }

            // 12-stack transitions
            if (u.trans >= 12) {
                u.trans -= 12;
                log(`&nbsp;&nbsp;&nbsp;üíé 12-Stack Transition`);
                units.forEach(a => {
                    if (u.name === "SQH") {
                        // Moon Abyss + Comet Hop: all heroes including self
                        tryBuff(a, "atk",    0.10, 2, "SQH Transition (Moon Abyss)");
                        addBuff(a, "allDmg", 0.10, 2, "SQH Transition (Moon Abyss)");
                        addBuff(a, "allDmgReduction", 0.20, 2, "SQH Transition (Moon Abyss)");
                        trackStat(a, "healingDone", 50);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH MOON ABYSS] ${a.name} +50% Max HP healed`, "#f59e0b");
                        tryBuff(a, "dr", 0.20, 2, "SQH Comet Hop");
                    }
                    if (u.name === "SQH") {
                        // Glowed Glory: +20 energy to ALL allies including self
                        a.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH GLOWED GLORY] ${a.name} +20 Energy (direct)`, "#f59e0b");
                        // Sun Halo + Acheron Barque: self only
                        if (a === u) {
                            addBuff(u, "allDmg", 0.15, 2, "SQH Sun Halo");
                            boss.spdDebuff = (boss.spdDebuff || 0) + 20;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH ACHERON BARQUE] Boss SPD -20 (total: -${boss.spdDebuff})`, "#f59e0b");
                        }
                    }
                    if (u.name === "BDSM") {
                        if (a.franticGluttony) {
                            addBuff(a, "atk", 0.25, 3, "BDSM Moon Abyss");
                            tryBuff(a, "cd",  0.25, 3, "BDSM Moon Abyss");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM MOON ABYSS] ${a.name} (FG) +25% ATK, +25% CD (3r, direct)`, "#ec4899");
                        }
                        a.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM GLOWED GLORY] ${a.name} +20 Energy (direct)`, "#ec4899");
                        if (a.isM) { addBuff(a, "allDmg", 0.15, 2, "BDSM Acheron Barque"); }
                        if (a === units[0]) {
                            boss.allDmgDealtDebuff = (boss.allDmgDealtDebuff || 0) + 0.10;
                            boss.allDmgDealtDebuffRounds = 2;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM COMET HOP] Boss All-Damage Dealt -10% for 2 rounds`, "#ec4899");
                        }
                        if (!a.isFr) { addBuff(a, "allDmg", 0.10, 2, "BDSM Sun Halo"); }
                    }
                    if (u.name === "LBRM") {
                        trackStat(u, "damageDealt", 3000);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANSITION] 30% Max HP dmg to frontline (capped 3000%)`, "#f0abfc");
                        let transEffect = Math.floor(Math.random() * 3);
                        if (transEffect === 0) {
                            units.filter(a => a.dreamMagicWings || a.mirrorMagicWings).forEach(a => {
                                tryBuff(a, "atk", 0.20, 2, "LBRM Trans Wings ATK");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 1] ${a.name} (Wings) +20% ATK 2r`, "#f0abfc");
                            });
                        } else if (transEffect === 1) {
                            units.filter(a => a.dreamMagicMagnification || a.mirrorMagicMagnification).forEach(a => {
                                addBuff(a, "allDmgReduction", 0.10, 2, "LBRM Trans Magnification DR");
                                a.hp = Math.min(100, a.hp + 33);
                                trackStat(a, "healingDone", 33);
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 2] ${a.name} (Magnification) +10% allDmgReduction 2r, +33% HP`, "#f0abfc");
                            });
                        } else {
                            units.filter(a => a.dreamMagicProtection || a.mirrorMagicProtection).forEach(a => {
                                a.beeSugarCoat = true;
                                refreshBuff(a, "ci", 0.50, 999, "Bee Sugar-coat CI");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 3] ${a.name} (Protection) Bee Sugar-coat +50% CI 4r`, "#f0abfc");
                            });
                        }
                        units.forEach(a => tryBuff(a, "armor", 0.35, 2, "LBRM Glowed Glory"));
                        let lbrmMaxAtk = units.find(a => a.isM) || units[0];
                        addBuff(lbrmMaxAtk, "allDmg", 0.15, 2, "LBRM Acheron Barque");
                        units.filter(a => !a.isFr).forEach(a => { addBuff(a, "allDmg", 0.10, 3, "LBRM Sun Halo"); });
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.10; boss.atkDebuffRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM PIVOTS] Glowed Glory armor+35% | Acheron Barque ${lbrmMaxAtk.name} +15%allDmg 2r | Comet Hop boss ATK-10% | Sun Halo backline +10%allDmg 3r`, "#f0abfc");
                    }
                    if (u.name === "LFA") {
                        trackStat(u, "damageDealt", 3000);
                        log(`&nbsp;&nbsp;&nbsp;üëø [LFA MOON ABYSS] 1500% ATK √ó 2 = 3000% ATK damage`, "#c084fc");
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.50; boss.atkDebuffRounds = 3;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA MOON ABYSS] Boss ATK -50% for 3 rounds`, "#c084fc");
                        trackStat(u, "damageDealt", 1000);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA GLOWED GLORY] +1000% ATK damage`, "#c084fc");
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.15; boss.atkDebuffRounds = Math.max(boss.atkDebuffRounds || 0, 2);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA ACHERON BARQUE] Boss ATK -15% (2r)`, "#c084fc");
                        refreshBuff(u, "ci", 0.20, 2, "LFA Comet Hop");
                        addBuff(u, "allDmg", 0.15, 2, "LFA Sun Halo");
                    }
                });
            }

            // Foresight / Destiny imprint
            if (imp === "foresight") {
                if (usedBasic) {
                    if (u.cc.seal <= 0 && checkC(u, "Foresight Energy +50")) { u.energy += 50; }
                    addBuff(u, "allDmg", 0.30, 15, "Foresight allDmg (basic)");
                }
                if (usedActive) {
                    tryBuff(u, "crit", 0.50, 2, "Foresight Crit (active)");
                    tryBuff(u, "cd", 1.00, 2, "Foresight CD (active)");
                }
            }
            if (usedBasic && imp === "destiny") {
                log(`&nbsp;&nbsp;&nbsp;‚ö° [DESTINY] Triggering for all allies`, "#38bdf8");
                units.forEach(a => {
                    if (Math.random() < 0.75) { if (checkC(a,"Destiny +20","+20")) a.energy += 20; }
                    if (Math.random() < 0.50) { if (checkC(a,"Destiny +20 bonus","+20")) a.energy += 20; }
                });
            }

            // BOSS COUNTERATTACK
            if (didHitBoss) {
                log(`&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [BOSS COUNTER] Corrupting Touch triggered!`, "#ef4444");
                units.forEach(h => {
                    h.calamity++;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ‚Üí ${h.name} +1 Calamity (now ${h.calamity})`, "#ef4444");
                    trigCal(h);
                    if (Math.random() < 0.5) { h.curse++; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ‚Üí ${h.name} +1 Curse (50%) (now ${h.curse})`, "#ef4444"); }
                });
            }
        }); // end ord.forEach

        log(`&nbsp;&nbsp;&nbsp;üî• END-OF-TURN CALAMITY CHECK`, "#ef4444");
        units.forEach(u => {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Üí ${u.name} Calamity: ${u.calamity}`, "#ef4444");
            trigCal(u);
        });

        let pupilUnits = units.filter(u => u.hasPupil);

        log(`&nbsp;&nbsp;&nbsp;‚òÑÔ∏è BOSS ACTIVE: CATASTROPHIC ROAR (3000% ATK √ó 3, +2 Cal & Curse, dodge applies)`, "#ef4444");
        boss.atkSteal = (boss.atkSteal || 0) + 0.08;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [CATASTROPHIC ROAR] Boss steals 8% ATK (3r), enemy Armor -100%`, "#ef4444");
        units.forEach(u => {
            let effectiveDodge = (u.pupilDodgeRounds > 0) ? 1.0 : u.dodge;
            if (u.pupilDodgeRounds > 0) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ${u.name} has Pupil 100% dodge active (${u.pupilDodgeRounds} rounds left)`, "#e879f9");
            }
            let dodged = Math.random() < effectiveDodge;
            if (dodged) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üí® ${u.name} DODGED the boss active! (no Calamity/Curse)`, "#a3e635");
                pupilUnits.forEach(pw => {
                    pw.energy += 10;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${pw.name} +10 Energy (ally ${u.name} dodged)`, "#e879f9");
                });
            } else {
                u.calamity += 2;
                u.curse += 2;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Üí ${u.name} +2 Calamity (now ${u.calamity}) & +2 Curse (now ${u.curse})`, "#ef4444");
                trigCal(u);

                let lbrm2 = units.find(x => x.name === "LBRM" && x.cc.seal <= 0);
                if (lbrm2 && lbrm2.energy >= 30) {
                    lbrm2.energy -= 30;
                    lbrm2.powerOfDream = Math.min(3, lbrm2.powerOfDream + 1);
                    let ccKeys2 = ["silence","fear","seal"].filter(k => u.cc[k] > 0);
                    if (ccKeys2.length > 0) { let rem2 = ccKeys2[Math.floor(Math.random()*ccKeys2.length)]; u.cc[rem2]=0; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON] ${u.name} ${rem2} removed, LBRM PoD=${lbrm2.powerOfDream}`, "#f0abfc"); }
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON DEEP] ${u.name} Shield 3500% ATK granted`, "#f0abfc");
                }
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ö° ${u.name} hit by boss active: +10 Energy`, "#38bdf8");
                if (checkC(u, "Boss Active Hit Energy", "+10")) u.energy += 10;

                let specterWearer = units.find(s => s.hasS);
                if (specterWearer && specterWearer.cc.seal <= 0) {
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîÆ ${u.name} Specter bonus: +10 Energy (boss hit)`, "#f472b6");
                    if (checkC(u, "Boss Active Hit Specter Bonus", "+10")) u.energy += 10;
                }

                if (u.name === "LBRM" && !u.mirrorMagicWingsUsed) {
                    u.mirrorMagicWingsUsed = true;
                    let ccK = ["silence","fear","seal"].filter(k => u.cc[k] > 0);
                    if (ccK.length > 0) {
                        let rk = ccK[Math.floor(Math.random()*ccK.length)];
                        u.cc[rk] = 0;
                        u.energy += 30;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [MIRROR WINGS] ${u.name} CC removed (${rk}), +30 energy`, "#f0abfc");
                    }
                }
                if (u.name === "STV") {
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE] STV hit by boss active`, "#a78bfa");
                    if (Math.random() < 0.80) {
                        boss.veilOfMist = true; boss.veilOfMistRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE] Boss: Veil of Mist applied (2r)`, "#a78bfa");
                        if (Math.random() < 0.70) {
                            applyLI("Fatal Allure (boss had VoM)");
                            if (Math.random() < 0.60) {
                                trackStat(u, "damageDealt", 800);
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE DEEP SUB] 800% ATK damage + boss -50 energy`, "#a78bfa");
                            }
                            let noSM = units.filter(a => !a.stygianMark);
                            if (noSM.length > 0) {
                                let pick = noSM[Math.floor(Math.random() * noSM.length)];
                                pick.stygianMark = true;
                                pick.stygianMarkStack = Math.min(2, (pick.stygianMarkStack || 0) + 1);
                                addBuff(pick, "allDmg", pick.stygianMarkStack * 0.10, 2, "Stygian Mark (Fatal Allure Noble)");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE NOBLE SUB] ${pick.name} gains Stygian Mark (2r)`, "#a78bfa");
                            }
                        }
                    }
                }
            }
            for (let k in u.cc) if (u.cc[k] > 0) u.cc[k]--;
        });

        log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è END-OF-ROUND CC CLEANSE`, "#a78bfa");
        const ccTypes = ["silence","fear","seal"];
        units.forEach(u => {
            let activeCC = ccTypes.filter(t => u.cc[t] > 0);
            if (activeCC.length > 0) {
                let pick = activeCC[Math.floor(Math.random() * activeCC.length)];
                u.cc[pick] = 0;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è ${u.name} removes ${pick.toUpperCase()}`, "#a78bfa");
            } else {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è ${u.name} has no CC to remove`, "#a78bfa");
            }
        });

        log(`&nbsp;&nbsp;&nbsp;ü™û ARTIFACT END-OF-ROUND PHASE`, "#38bdf8");

        boss.spiritMirrorRound++;
        let smWearers = units.filter(u => u.art === "Spiritual Mirror" && u.cc.seal <= 0);
        if (smWearers.length > 0 && (boss.spiritMirrorRound === 1 || boss.spiritMirrorRound % 3 === 0)) {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SPIRITUAL MIRROR] Every-3-round pulse (round ${boss.spiritMirrorRound})`, "#38bdf8");
            units.forEach(a => {
                let hasSM = a.art === "Spiritual Mirror";
                let mult = hasSM ? 2 : 1;
                addBuff(a, "allDmg", 0.045 * mult, 3, `Spiritual Mirror allDmg (√ó${mult})`);
                addBuff(a, "dr", 0.03 * mult, 3, `Spiritual Mirror DR (√ó${mult})`);
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SM] ${a.name}: +${(4.5*mult).toFixed(1)}% allDmg, +${(3*mult).toFixed(0)}% DR (3r decay)`, "#38bdf8");
            });
            boss.ciDebuff = (boss.ciDebuff || 0) + 0.03;
            boss.ciDebuffRounds = 3;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SM] Boss CI -3% (3r decay)`, "#38bdf8");
        }

        units.forEach(u => {
            if (u.cc.seal > 0) return;
            if (u.art === "Spiritual Mirror") {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SPIRITUAL MIRROR] EoR: +15 energy & +6% HP to all allies`, "#38bdf8");
                units.forEach(a => {
                    a.energy += 15;
                    a.hp = Math.min(100, a.hp + 6);
                    trackStat(a, "healingDone", 6);
                });
            }

            // ‚îÄ‚îÄ SCISSORS: replicate boss ATK & HD to self + same-line allies only ‚îÄ‚îÄ
            if (u.art === "Scissors") {
                let totalBossATK = (boss.atkBuff || 0) + (boss.atkSteal || 0);
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è [SCISSORS] Boss total ATK: +${(totalBossATK*100).toFixed(0)}% (atkBuff ${((boss.atkBuff||0)*100).toFixed(0)}% + atkSteal ${((boss.atkSteal||0)*100).toFixed(0)}%) ‚Üí 30% replicated to self + same-line allies`, "#38bdf8");
                // Only buff self + allies on the same line (frontline or backline)
                let scissorsTargets = units.filter(a => a.isFr === u.isFr);
                scissorsTargets.forEach(a => {
                    if (totalBossATK > 0) {
                        let replicatedATK = totalBossATK * 0.30;
                        if (checkC(a, "Scissors ATK repl.")) {
                            addBuff(a, "atk", replicatedATK, 15, "Scissors (boss ATK repl.)");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è ${a.name}: +${(replicatedATK*100).toFixed(1)}% ATK (30% of +${(totalBossATK*100).toFixed(0)}%)`, "#38bdf8");
                        }
                    }
                    if (bossHDStacks > 0) {
                        let replicatedHD = bossHDStacks * 0.125 * 0.30;
                        if (checkC(a, "Scissors HD repl.")) {
                            addBuff(a, "hd", replicatedHD, 15, "Scissors (boss HD repl.)");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è ${a.name}: +${(replicatedHD*100).toFixed(1)}% HD (30% of boss ${(bossHDStacks*12.5).toFixed(1)}% HD)`, "#38bdf8");
                        }
                    }
                });
            }

            if (u.art === "Antlers") {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü¶å [ANTLERS] ${u.name}: +9% allDmg (permanent), +1% DR (2r, offsettable)`, "#38bdf8");
                addBuff(u, "allDmg", 0.09, 999, "Antlers Power of Wildness allDmg");
                tryBuff(u, "dr", 0.01, 10, "Antlers Power of Wildness DR");
            }
            // ‚îÄ‚îÄ Specter EoR Pulse (rounds 1-5): fires during the specter holder's artifact turn ‚îÄ‚îÄ
            if (r <= 5 && u.hasS && u.cc.seal <= 0) {
                log(`&nbsp;&nbsp;&nbsp;üîÆ [SPECTER EoR PULSE R${r}/5] ${u.name}`, "#f472b6");
                if (checkC(u, "Specter EoR Self", "+50")) u.energy += 50;
                let specAllies = units.filter(a => a !== u);
                let randSA = specAllies[Math.floor(Math.random() * specAllies.length)];
                if (checkC(randSA, "Specter EoR Ally", "+50")) randSA.energy += 50;
            }
            // ‚îÄ‚îÄ Global Surge: each hero gets +50 energy after their own EoR actions ‚îÄ‚îÄ
            if (checkC(u, "Global Surge", "+50")) u.energy += 50;
        });

        log(`&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ABYSSAL INVASION (boss end-of-round)`, "#ef4444");
        let invasionTarget = units.find(u => u.isM);
        if (invasionTarget) {
            invasionTarget.energy = Math.max(0, invasionTarget.energy - 100);
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} -100 Energy (now ${invasionTarget.energy})`, "#ef4444");
            invasionTarget.curse += 3;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} +3 Curse of Decay (now ${invasionTarget.curse})`, "#ef4444");
            invasionTarget.buffs.atk.push({ value: -0.40, rounds: 2, source: "Abyssal Invasion ATK debuff" });
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} ATK -40% for 2 rounds`, "#ef4444");
        }
        boss.atkBuff = (boss.atkBuff || 0) + 0.06;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] Boss self +6% ATK (total: +${((boss.atkBuff||0)*100).toFixed(0)}%)`, "#ef4444");
        units.forEach(u => {
            if (u.calamity > 0) {
                if (Math.random() < 0.25) {
                    let buffTypes = Object.keys(u.buffs).filter(t => u.buffs[t].filter(b => b.value > 0).length > 0);
                    if (buffTypes.length > 0) {
                        let pick = buffTypes[Math.floor(Math.random() * buffTypes.length)];
                        let idx = u.buffs[pick].findIndex(b => b.value > 0);
                        let removed = u.buffs[pick].splice(idx, 1)[0];
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${u.name} (25% proc): ${pick.toUpperCase()} +${(removed.value*100).toFixed(1)}% buff removed`, "#ef4444");
                    }
                }
            } else {
                u.calamity++;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${u.name} (no Calamity): +1 Calamity`, "#ef4444");
                trigCal(u);
            }
        });

        // Specter EoR pulse is now inline in the artifact loop below

        log(`&nbsp;&nbsp;&nbsp;‚ùÑÔ∏è CALAMITY PURGE (-1 per hero)`, "#a5b4fc");
        units.forEach(u => {
            if (u.calamity > 0) { u.calamity--; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ùÑÔ∏è ${u.name}: -1 Cal (now ${u.calamity})`, "#a5b4fc"); }
        });

        log(`&nbsp;&nbsp;&nbsp;‚è±Ô∏è BUFF TICK (end of round)`, "#34d399");
        units.forEach(u => {
            tickBuffs(u);
            if (u.stygianMark) { u.stygianMark = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [SM] ${u.name} Stygian Mark expired`, "#64748b"); }
            if (u.veilOfMist) { u.veilOfMistRounds--; if (u.veilOfMistRounds <= 0) { u.veilOfMist = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [VoM] ${u.name} Veil of Mist expired`, "#64748b"); } }
            if (u.fearAbyssalGaze) { u.fearAbyssalGazeRounds--; if (u.fearAbyssalGazeRounds <= 0) { u.fearAbyssalGaze = false; log(`&nbsp;&nbsp;&nbsp;üëπ [FAG] ${u.name} Fear-Abyssal Gaze expired`, "#64748b"); } }
            if (u.lethalIncense) { u.lethalIncenseRounds--; if (u.lethalIncenseRounds <= 0) { u.lethalIncense = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [LI] ${u.name} Lethal Incense expired ‚Äî ally takes 30% Max HP damage`, "#a78bfa"); let stvH = units.find(s => s.name === "STV"); if (stvH) trackStat(stvH, "damageDealt", 1500); } }
        });
        if (boss.lethalIncense) {
            boss.lethalIncenseRounds--;
            if (boss.lethalIncenseRounds <= 0) { let stvH = units.find(s => s.name === "STV"); expireLI(stvH); }
        }
        if (boss.veilOfMist) { boss.veilOfMistRounds--; if (boss.veilOfMistRounds <= 0) { boss.veilOfMist = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [VoM] Boss Veil of Mist expired`, "#64748b"); } }
        if (boss.healReductionRounds > 0) { boss.healReductionRounds--; if (boss.healReductionRounds <= 0) { boss.healReduction = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduction expired`, "#64748b"); } }

        if (boss.bleed && boss.bleed.length > 0) {
            log(`&nbsp;&nbsp;&nbsp;ü©∏ BLEED PHASE`, "#f59e0b");
            let totalBleedDmg = 0;
            boss.bleed = boss.bleed.map(b => {
                totalBleedDmg += b.dmg;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü©∏ Bleed tick: ${b.dmg}% ATK (${b.rounds - 1} rounds remaining)`, "#f59e0b");
                return { ...b, rounds: b.rounds - 1 };
            }).filter(b => b.rounds > 0);
            let sqh = units.find(u => u.name === "SQH");
            if (sqh) trackStat(sqh, "damageDealt", totalBleedDmg);
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü©∏ Total Bleed damage this round: ${totalBleedDmg}% ATK`, "#f59e0b");
        }

        if (boss.critDebuffRounds > 0) { boss.critDebuffRounds--; if (boss.critDebuffRounds <= 0) { boss.critDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üëë [SQH] Boss Crit debuff expired`, "#64748b"); } }
        if (boss.drDebuffRounds > 0) { boss.drDebuffRounds--; if (boss.drDebuffRounds <= 0) { boss.drDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss DR debuff expired`, "#64748b"); } }
        if (boss.ciDebuffRounds > 0) { boss.ciDebuffRounds--; if (boss.ciDebuffRounds <= 0) { boss.ciDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss CI debuff expired`, "#64748b"); } }
        if (boss.allDmgReductionDebuffRounds > 0) { boss.allDmgReductionDebuffRounds--; if (boss.allDmgReductionDebuffRounds <= 0) { boss.allDmgReductionDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss AllDmgReduction debuff expired`, "#64748b"); } }
        if (boss.allDmgDealtDebuffRounds > 0) { boss.allDmgDealtDebuffRounds--; if (boss.allDmgDealtDebuffRounds <= 0) { boss.allDmgDealtDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss AllDmgDealt debuff expired`, "#64748b"); } }
        if (boss.atkSteal > 0) { log(`&nbsp;&nbsp;&nbsp;üëø [LFA DKM] Boss ATK stolen this fight: -${(boss.atkSteal*100).toFixed(0)}% ATK (permanent)`, "#c084fc"); }
        if (boss.atkDebuffRounds > 0) { boss.atkDebuffRounds--; if (boss.atkDebuffRounds <= 0) { boss.atkDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss ATK debuff expired`, "#64748b"); } }
        if (boss.armorDebuffRounds > 0) { boss.armorDebuffRounds--; if (boss.armorDebuffRounds <= 0) { boss.armorDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss Armor debuff expired`, "#64748b"); } }
        if (boss.spdDebuffRounds > 0) { boss.spdDebuffRounds--; if (boss.spdDebuffRounds <= 0) { boss.spdDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss SPD debuff expired`, "#64748b"); } }

        units.forEach(u => {
            if (u.name === "SQH") {
                let aliveAllies = units.length;
                let healing = aliveAllies * 8;
                trackStat(u, "healingDone", healing);
                log(`&nbsp;&nbsp;&nbsp;üëë [SQH ULTIMATE QUEENSHIP] ${aliveAllies} allies ‚Üí +${healing}% Max HP restored`, "#f59e0b");
            }
        });

        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è PUPIL DODGE RESET (Max ATK hero dodge resets to base)`, "#e879f9");
        units.forEach(u => {
            if (u.dodge !== u.baseDodge) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ${u.name} Dodge reset: ${Math.round(u.dodge*100)}% ‚Üí ${Math.round(u.baseDodge*100)}%`, "#e879f9");
                u.dodge = u.baseDodge;
            }
        });
    }

    return { units, hd: bossHDStacks, boss };
}

function sim(multi) {
    const out = document.getElementById('output'); out.innerHTML = ""; silent = multi;
    if (!multi) {
        runOne();
    } else {
        const N = 1000;
        let stats = {}, totalHD = 0, minHD = Infinity, maxHD = -Infinity;
        for (let i = 0; i < N; i++) {
            let res = runOne();
            totalHD += res.hd;
            minHD = Math.min(minHD, res.hd);
            maxHD = Math.max(maxHD, res.hd);
            res.units.forEach(u => {
                if (!stats[u.name]) stats[u.name] = {
                    acts:0, lost:0,
                    finalATK:0, minATK:Infinity, maxATK:-Infinity,
                    finalAllDmg:0, minAllDmg:Infinity, maxAllDmg:-Infinity,
                    finalHD:0, minHD:Infinity, maxHD:-Infinity,
                    finalCI:0, minCI:Infinity, maxCI:-Infinity,
                    baseCI: u.baseCI
                };
                let s = stats[u.name];
                let atkExtra = (u.name === "LFA" && res.boss) ? (res.boss.atkSteal || 0) : 0;
                let atk = getBuffTotal(u, "atk") + atkExtra;
                let ad  = getBuffTotal(u, "allDmg");
                let hd  = getBuffTotal(u, "hd");
                let ci  = u.baseCI + getBuffTotal(u, "ci");
                s.acts += u.acts; s.lost += u.turnsLost;
                s.finalATK += atk; s.minATK = Math.min(s.minATK, atk); s.maxATK = Math.max(s.maxATK, atk);
                s.finalAllDmg += ad; s.minAllDmg = Math.min(s.minAllDmg, ad); s.maxAllDmg = Math.max(s.maxAllDmg, ad);
                s.finalHD += hd; s.minHD = Math.min(s.minHD, hd); s.maxHD = Math.max(s.maxHD, hd);
                s.finalCI += ci; s.minCI = Math.min(s.minCI, ci); s.maxCI = Math.max(s.maxCI, ci);
            });
        }
        function pct(v) { return `${(v*100).toFixed(1)}%`; }
        function range(avg, mn, mx) {
            return `<span style="color:var(--accent)">${pct(avg)}</span> <small style="color:#64748b">[${pct(mn)} ‚Äì ${pct(mx)}]</small>`;
        }
        let html = `<h3>AVERAGES + RANGES (${N} FIGHTS)</h3>`;
        html += `<p><b>Boss Holy Damage Stacks:</b> avg <span style="color:var(--accent)">${(totalHD/N).toFixed(2)}</span> stacks (+${(totalHD/N*12.5).toFixed(1)}% HD) &nbsp;|&nbsp; range <small style="color:#64748b">[${minHD} ‚Äì ${maxHD} stacks / +${(minHD*12.5).toFixed(1)}% ‚Äì +${(maxHD*12.5).toFixed(1)}% HD]</small></p>`;
        html += `<table><tr><th>Hero</th><th>Base CI</th><th>Avg Actives</th><th>Avg CC Lost</th><th>Final ATK (avg [min‚Äìmax])</th><th>Final allDmg (avg [min‚Äìmax])</th><th>Final Eff. CI (avg [min‚Äìmax])</th><th>Final HD (avg [min‚Äìmax])</th></tr>`;
        for (let n in stats) {
            let s = stats[n];
            html += `<tr>
                <td>${n}</td>
                <td>${(s.baseCI*100).toFixed(0)}%</td>
                <td>${(s.acts/N).toFixed(2)}</td>
                <td>${(s.lost/N).toFixed(2)}</td>
                <td>${range(s.finalATK/N, s.minATK, s.maxATK)}</td>
                <td>${range(s.finalAllDmg/N, s.minAllDmg, s.maxAllDmg)}</td>
                <td>${range(s.finalCI/N, s.minCI, s.maxCI)}</td>
                <td>${range(s.finalHD/N, s.minHD, s.maxHD)}</td>
            </tr>`;
        }
        out.innerHTML = html + `</table>`;
    }
}
</script>
</body>
</html>
