
<!DOCTYPE html>
<html>
<head>
    <title>Curse of Decay: Full Restoration & HD Tracking</title>
    <style>
        :root { --bg: #0b0e14; --card: #1a1f2e; --accent: #38bdf8; --text: #cbd5e1; --border: #334155; }
        body { font-family: 'Consolas', monospace; background: var(--bg); color: var(--text); padding: 20px; font-size: 12px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 20px; }
        .card { background: var(--card); border: 1px solid var(--border); padding: 12px; border-radius: 4px; }
        .card h3 { margin: 0 0 8px 0; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom:4px; }
        input, select { background: #000; color: #fff; border: 1px solid var(--border); padding: 4px; width: 100%; margin: 4px 0; box-sizing:border-box; }
        label { display:block; margin: 3px 0; }
        button { padding: 15px; font-weight: bold; cursor: pointer; border: 1px solid var(--accent); background: transparent; color: var(--accent); margin-top: 10px; width: 100%; }
        button:hover { background: var(--accent); color: #000; }
        #output { background: #000; border: 1px solid var(--border); padding: 15px; height: 600px; overflow-y: auto; line-height: 1.5; margin-top: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 11px; }
        th, td { border: 1px solid var(--border); padding: 6px; text-align: left; }
        th { background: #111; color: var(--accent); }
        small { color: #64748b; }
    </style>
</head>
<body>

<div style="background:#1a1f2e;border:1px solid #334155;border-radius:8px;padding:10px 16px;margin-bottom:10px;display:flex;align-items:center;gap:20px;flex-wrap:wrap;">
  <span style="color:#94a3b8;font-size:12px;font-weight:bold">Global CI Bonuses:</span>
  <label style="font-size:12px;color:#cbd5e1;display:flex;align-items:center;gap:6px;">
    SE Train CI:
    <input type="number" id="seTrainCI" value="17" min="0" max="200" style="width:60px;background:#0b0e14;border:1px solid #334155;border-radius:4px;color:#38bdf8;padding:2px 6px;font-size:12px;" oninput="updateAllCardCI()">
    <span style="color:#64748b;font-size:11px">% added to all heroes</span>
  </label>
  <label style="font-size:12px;color:#cbd5e1;display:flex;align-items:center;gap:6px;">
    Pet CI:
    <input type="number" id="petCI" value="10" min="0" max="200" style="width:60px;background:#0b0e14;border:1px solid #334155;border-radius:4px;color:#a78bfa;padding:2px 6px;font-size:12px;" oninput="updateAllCardCI()">
    <span style="color:#64748b;font-size:11px">% added to all heroes</span>
  </label>
  <span id="globalCITotal" style="color:#4ade80;font-size:11px"></span>
</div>
<div class="grid" id="hero-inputs"></div>

<div class="card" style="margin-bottom:12px;">
    <h3>üëÅÔ∏è Pupil ‚Äî 3 Lowest HP Heroes</h3>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <div style="flex:1"><label>Lowest HP #1</label><select id="lowhp0"><option value="">-- None --</option></select></div>
        <div style="flex:1"><label>Lowest HP #2</label><select id="lowhp1"><option value="">-- None --</option></select></div>
        <div style="flex:1"><label>Lowest HP #3</label><select id="lowhp2"><option value="">-- None --</option></select></div>
    </div>
    <small style="margin-top:4px;display:block;">Every 4 Pupil-wearer actions ‚Üí these 3 heroes get 100% boss-active dodge for 2 rounds.</small>
</div>

<div class="card" style="margin-bottom:20px;">
    <h3>Environment Controls</h3>
    <div style="display:flex; gap:20px;">
        <div style="flex:1"><label>Global Star Imprint</label>
            <select id="gImp"><option value="none">None</option><option value="foresight" selected>Foresight</option><option value="destiny">Destiny</option></select>
        </div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl8" checked> Island 8 (+3% allDmg per ally active)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl9" checked> Island 9 (allDmgReduction decay + HD ramp)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl10" checked> Island 10 (+25% allDmg all at round start)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="isl11" checked> Island 11 (Soul Protection ‚Äî random CC immunity)</label></div>
        <div style="flex:1; margin-top:15px;"><label><input type="checkbox" id="fearGT" checked> Fear Guild Train (sub-100 CI bonus applies to Fear)</label></div>
        <div style="flex:1; margin-top:15px;">
            <label>Boss HP Tier</label>
            <select id="bossHP">
                <option value="above70">Above 70%</option>
                <option value="60-69">60‚Äì69%</option>
                <option value="50-59" selected>50‚Äì59%</option>
                <option value="below50">Below 50%</option>
            </select>
        </div>
    </div>
</div>

<!-- ‚ïê‚ïê‚ïê DAMAGE CALCULATOR (collapsible) ‚ïê‚ïê‚ïê -->
<div style="margin-top:20px;">
    <button onclick="toggleDmgCalc()" style="background:var(--card);border:1px solid #334155;width:100%;text-align:left;padding:10px 14px;font-size:14px;cursor:pointer;">
        ‚öîÔ∏è Damage Calculator (Max ATK Hero) <span id="dmgCalcArrow">‚ñº</span>
    </button>
    <div id="dmgCalcPanel" style="display:none;background:var(--card);border:1px solid #334155;border-top:none;padding:16px;border-radius:0 0 8px 8px;">
        <p style="color:#94a3b8;font-size:12px;margin-top:0;">Set base stats for the highest ATK hero (<span id="dcHeroLabel" style="color:var(--accent);font-weight:bold">LFA</span>). Used to compute damage output per active.</p>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;">
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">ATK (absolute)</label>
                <input type="number" id="dc_atk" value="750000000" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Skill DMG %</label>
                <input type="number" id="dc_skill" value="1500" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Precision %</label>
                <input type="number" id="dc_prec" value="150" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Holy DMG % (base)</label>
                <input type="number" id="dc_holy" value="230" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">All DMG Dealt %</label>
                <input type="number" id="dc_alldmg" value="140" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Crit %</label>
                <input type="number" id="dc_crit" value="35" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Crit DMG %</label>
                <input type="number" id="dc_cd" value="150" style="width:100%">
            </div>
            <div>
                <label style="font-size:11px;color:#94a3b8;display:block;margin-bottom:3px;">Temple DMG %</label>
                <input type="number" id="dc_temple" value="160" min="0" placeholder="e.g. 150" style="width:100%">
            </div>
            <div style="display:flex;align-items:center;gap:12px;padding-top:18px;">
                <label style="font-size:12px;"><input type="checkbox" id="dc_defier" checked> Defier</label>
                <label style="font-size:12px;"><input type="checkbox" id="dc_gk" checked> Giant Killer</label>
            </div>
        </div>
    </div>
</div>

<button onclick="sim(false)">Simulate 15-Round Battle (Full Log)</button>
<button onclick="sim(true)">Statistical Batch (1000 Fights Summary)</button>
<label style="font-size:12px;color:#cbd5e1;margin-right:12px;vertical-align:middle"><input type="checkbox" id="relaxSpeeds"> Relax Speed Order (optimizer tests all speed assignments)</label>
<label style="font-size:12px;color:#38bdf8;margin-right:12px;vertical-align:middle"><input type="checkbox" id="safeMode"> üåä ELY Safe Mode (guarantees shrink every action)</label>
<button onclick="runOptimizer()" id="optBtn" style="background:linear-gradient(135deg,#7c3aed,#4f46e5);border:none;color:#fff;padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:bold;font-size:14px;">‚ö° Find Optimal Build</button>
<button onclick="runCritOptimizer()" id="critOptBtn" style="background:linear-gradient(135deg,#0ea5e9,#0369a1);border:none;color:#fff;padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:bold;font-size:14px;">üéØ Optimal Crit %</button>
<div id="critOptProgress" style="display:none;margin-top:10px;padding:10px 14px;background:var(--card);border-radius:8px;font-size:13px;color:#94a3b8;"></div>
<div id="critOptOutput"></div>
<div id="optProgress" style="display:none;margin-top:10px;padding:10px 14px;background:var(--card);border-radius:8px;font-size:13px;color:#94a3b8;"></div>
<div id="optOutput"></div>
<div id="output"></div>

<script>
const HEROES = ["LFA","SQH","STV","BDSM","LBRM","ELY","HW","DGN"];
const ARTS   = ["None","Demon Bell","Spiritual Mirror","Antlers","Scissors","Antiwarrior","Jade Toad"];
const defaults = [
    { h:"BDSM", a:"Demon Bell",       s:2000, ci:67  },
    { h:"SQH",  a:"Spiritual Mirror", s:1900, ci:67  },
    { h:"LFA",  a:"Antlers",          s:1500, ci:80  },
    { h:"HW",   a:"Scissors",         s:1800, ci:65  },
    { h:"ELY",  a:"Scissors",         s:1700, ci:95  },
    { h:"STV",  a:"Scissors",         s:1600, ci:85  }
];

const container = document.getElementById('hero-inputs');
defaults.forEach((d, i) => {
    container.innerHTML += `<div class="card">
        <h3>POS ${i+1}</h3>
        <select id="h${i}" onchange="updateDCLabel();updateCardCI(${i})">${HEROES.map(h=>`<option value="${h}" ${h===d.h?'selected':''}>${h}</option>`).join('')}</select>
        <select id="a${i}" onchange="updateCardCI(${i})">${ARTS.map(a=>`<option value="${a}" ${a===d.a?'selected':''}>${a}</option>`).join('')}</select>
        <div style="display:flex;gap:5px;margin-top:4px;">
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">SPD</label>
                <input type="number" id="s${i}" value="${d.s}" placeholder="SPD" style="width:100%">
            </div>
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">Base CI %</label>
                <input type="number" id="ci${i}" value="${d.ci}" placeholder="CI%" style="width:100%" oninput="updateCardCI(${i})">
            </div>
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">Dodge %</label>
                <input type="number" id="dg${i}" value="0" min="0" max="100" placeholder="Dodge%" style="width:100%">
            </div>
        </div>
        <div style="display:flex;gap:5px;margin-top:4px;">
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">Pre-Battle DR %</label>
                <input type="number" id="dr${i}" value="0" min="0" placeholder="DR%" style="width:100%">
            </div>
            <div style="flex:1">
                <label style="font-size:10px;color:#94a3b8;display:block;margin-bottom:2px;">All DMG Reduction %</label>
                <input type="number" id="adr${i}" value="0" min="0" placeholder="ADR%" style="width:100%">
            </div>
        </div>
        <div style="margin-top:6px;display:flex;flex-direction:column;gap:4px;">
            <div style="display:flex;gap:3px;">
                <label style="flex:1;font-size:11px;background:#1e293b;border:1px solid #334155;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer"><input type="checkbox" id="spec${i}"> Specter</label>
                <label style="flex:1;font-size:11px;background:#1e293b;border:1px solid #334155;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer"><input type="checkbox" id="pupil${i}"> Pupil</label>
                <label style="flex:1;font-size:11px;background:#1e293b;border:1px solid #334155;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer"><input type="checkbox" id="nova${i}"> Nova</label>
            </div>
            <div style="display:flex;gap:3px;">
                <label style="flex:1;font-size:11px;background:#1e293b40;border:1px solid #ef444430;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer;color:#fca5a5"><input type="checkbox" id="fearImm${i}"> Fear</label>
                <label style="flex:1;font-size:11px;background:#78350f30;border:1px solid #f59e0b50;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer;color:#fcd34d"><input type="checkbox" id="sealImm${i}"> Seal</label>
                <label style="flex:1;font-size:11px;background:#1e3a5f40;border:1px solid #38bdf850;border-radius:5px;padding:3px 5px;display:flex;align-items:center;gap:4px;cursor:pointer;color:#7dd3fc"><input type="checkbox" id="silImm${i}"> Silence</label>
            </div>
        </div>
        <div style="margin-top:4px;display:flex;flex-wrap:wrap;gap:4px;align-items:center;">
            <label style="font-size:11px" id="stellarLbl${i}"><input type="checkbox" id="stellar${i}" onchange="updateCardCI(${i})"> Void CI (+35)</label>
            <span style="font-size:11px;color:#38bdf8;font-weight:bold" id="effCI${i}"></span>
        </div>
        <label style="margin-top:4px;display:block;font-size:11px"><input type="radio" name="max" value="${i}" ${i===0?'checked':''} onchange="updateDCLabel()"> Max ATK</label>
        <label style="margin-top:4px;display:block;font-size:11px;color:#a78bfa"><input type="checkbox" id="upgPurify${i}"> ‚ú¶ Upgraded Control Purify</label>
    </div>`;
});

function refreshLowHPDropdowns() {
    for (let s = 0; s < 3; s++) {
        let sel = document.getElementById(`lowhp${s}`);
        let cur = sel.value;
        sel.innerHTML = '<option value="">-- None --</option>';
        for (let i = 0; i < 6; i++) {
            let name = document.getElementById(`h${i}`).value;
            sel.innerHTML += `<option value="${i}" ${cur==i?'selected':''}>${name} (POS ${i+1})</option>`;
        }
    }
}
window.addEventListener('load', () => {
    // Default checkboxes: BDSM(0)=nova, SQH(1)=pupil, LFA(2)=specter
    document.getElementById('nova0')?.setAttribute('checked', 'checked');
    document.getElementById('nova0').checked = true;
    document.getElementById('pupil1')?.setAttribute('checked', 'checked');
    document.getElementById('pupil1').checked = true;
    document.getElementById('spec2')?.setAttribute('checked', 'checked');
    document.getElementById('spec2').checked = true;

    // Default lowhp: HW(3), ELY(4), STV(5)
    refreshLowHPDropdowns();
    ['lowhp0','lowhp1','lowhp2'].forEach((id, i) => {
        let sel = document.getElementById(id);
        if (sel) sel.value = String(3 + i);
    });

    for (let i = 0; i < 6; i++) {
        document.getElementById(`h${i}`).addEventListener('change', refreshLowHPDropdowns);
        updateCardCI(i);
        document.getElementById(`a${i}`)?.addEventListener('change', () => updateCardCI(i));
    }
});

let units = [], boss = {}, silent = false, bossHDStacks = 0, bossHPTier = "above70";

function log(msg, color="#fff") {
    if (!silent) document.getElementById('output').innerHTML += `<div style="color:${color}">${msg}</div>`;
}

function checkC(u, type, amount="") {
    if (u.curse > 0) {
        u.curse--;
        log(`&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${u.name}: ${type} ${amount}`, "#fbbf24");
        return false;
    }
    log(`&nbsp;&nbsp;&nbsp;‚úÖ [BUFF LANDED] ${u.name}: ${type} ${amount}`, "#4ade80");
    return true;
}

function addBuff(u, type, value, rounds, source) {
    u.buffs[type].push({ value, rounds, source });
    let total = getBuffTotal(u, type);
    let extraInfo = (type === "ci") ? ` | Effective CI: ${((u.baseCI + total)*100).toFixed(0)}%` : "";
    log(`&nbsp;&nbsp;&nbsp;üìä [BUFF] ${u.name} +${(value*100).toFixed(0)}% ${type.toUpperCase()} (${rounds}r) from ${source} | Total ${type.toUpperCase()}: +${(total*100).toFixed(0)}%${extraInfo}`, "#34d399");
}
// Like addBuff but no log ‚Äî used when caller logs a grouped summary instead
function addBuffSilent(u, type, value, rounds, source) {
    u.buffs[type].push({ value, rounds, source });
}
// Refresh semantics: remove all existing stacks from same source, then add fresh one.
// Use for short-duration buffs that reapply (prevents unbounded stacking).
function refreshBuff(u, type, value, rounds, source) {
    u.buffs[type] = u.buffs[type].filter(b => b.source !== source);
    addBuff(u, type, value, rounds, source);
}
// Silent version of refreshBuff (for batch/grouped logging)
function refreshBuffSilent(u, type, value, rounds, source) {
    u.buffs[type] = u.buffs[type].filter(b => b.source !== source);
    u.buffs[type].push({ value, rounds, source });
}

function getBuffTotal(u, type) {
    return u.buffs[type].reduce((sum, b) => sum + b.value, 0);
}

function tickBuffs(u) {
    const types = Object.keys(u.buffs);
    types.forEach(type => {
        let expired = [];
        u.buffs[type] = u.buffs[type]
            .map(b => ({ ...b, rounds: b.rounds - 1 }))
            .filter(b => {
                if (b.rounds <= 0) { expired.push(b); return false; }
                return true;
            });
        if (expired.length === 0) return;
        // Group by (value, source-prefix) to collapse repeated ticks
        let groups = {};
        expired.forEach(b => {
            let key = `${(b.value*100).toFixed(0)}%|${b.source.replace(/ tick \d+$/, " tick N")}`;
            if (!groups[key]) groups[key] = { b, count: 0 };
            groups[key].count++;
        });
        Object.values(groups).forEach(({ b, count }) => {
            let label = b.source.replace(/ tick \d+$/, " ticks");
            let countStr = count > 1 ? ` √ó${count}` : "";
            log(`&nbsp;&nbsp;&nbsp;‚è±Ô∏è [BUFF EXPIRED] ${u.name} ${type.toUpperCase()} +${(b.value*100).toFixed(0)}%${countStr} (${label})`, "#64748b");
        });
    });
}

function tryBuff(u, type, value, rounds, source) {
    if (u.curse > 0) {
        u.curse--;
        log(`&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${u.name}: ${source} ${type.toUpperCase()} +${(value*100).toFixed(0)}%`, "#fbbf24");
        return false;
    }
    addBuff(u, type, value, rounds, source);
    return true;
}

function trackStat(u, key, value) {
    u.stats[key] = (u.stats[key] || 0) + value;
}

function trigCal(u) {
    if (u.calamity >= 5) {
        let effectiveCI = u.baseCI + getBuffTotal(u, "ci");
        let fearCI = effectiveCI - (u.fearCIPenalty || 0);
        let pStd  = Math.max(0, 2.0 - effectiveCI); // silence & seal
        let pFear = Math.max(0, 2.0 - fearCI);       // fear (may be higher if GT off)
        // Track peak and average CI for summary reporting
        if (effectiveCI > u.peakCI) u.peakCI = effectiveCI;
        u.ciTotal += effectiveCI; u.ciSamples++;
        let fearNote = (u.fearCIPenalty > 0) ? ` | Fear CI: ${(fearCI*100).toFixed(0)}% (GT off, chance ${(pFear*100).toFixed(0)}%)` : "";
        log(`&nbsp;&nbsp;&nbsp;üí† [CI CHECK] ${u.name} effectiveCI=${(effectiveCI*100).toFixed(0)}% (base ${(u.baseCI*100).toFixed(0)}% + buffs +${(getBuffTotal(u,"ci")*100).toFixed(0)}%) ‚Üí CC chance ${(pStd*100).toFixed(0)}%${fearNote}`, "#38bdf8");
        ["silence","fear","seal"].forEach(t => {
            let p = (t === "fear") ? pFear : pStd;
            const isImm = (t === "fear" && u.fearImm) || (t === "seal" && u.sealImm) || (t === "silence" && u.silImm);
            if (isImm) { log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è [CC IMMUNE] ${u.name} is immune to ${t.toUpperCase()}`, "#4ade80"); return; }
            if (u.imm !== t && Math.random() < p) {
                u.cc[t] = 2;
                log(`&nbsp;&nbsp;&nbsp;üõë [CC APPLIED] ${u.name} is ${t.toUpperCase()}ED!`, "#ef4444");
                if (t === "fear") {
                    bossHDStacks++;
                    boss.holyDmg = (boss.holyDmg || 0) + 0.125;
                    log(`&nbsp;&nbsp;&nbsp;üìà [BOSS HD] Fear on ${u.name} ‚Üí +12.5% Holy Dmg | Total: ${bossHDStacks} stacks (+${(bossHDStacks*12.5).toFixed(1)}%)`, "#38bdf8");
                }
            }
        });
        u.calamity = 0;
    }
}

function grantFG(target, bdsm) {
    let isNew = !target.franticGluttony;
    target.franticGluttony = true;
    target.franticGluttonyRounds = 2;
    log(`&nbsp;&nbsp;&nbsp;üå∏ [FRANTIC GLUTTONY] ${target.name} gains FG (${isNew ? 'new' : 'refreshed'})`, "#ec4899");
    if (isNew) {
        addBuff(target, "atk", 0.15, 999, "Frantic Gluttony");
        addBuff(target, "spd", 0.20, 999, "Frantic Gluttony SPD");
    }
    const ccList = ["silence","fear","seal"];
    let active = ccList.filter(t => target.cc[t] > 0);
    if (active.length > 0) {
        let pick = active[Math.floor(Math.random() * active.length)];
        target.cc[pick] = 0;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è [BDSM DEEP SUB] ${target.name}: ${pick.toUpperCase()} cleansed via FG grant`, "#a78bfa");
    }
    if (isNew) {
        addBuff(target, "drOffset", 0.20, 999, "FG ‚â•40% Shield DR Offset");
        addBuff(target, "allDmg",   0.10, 999, "FG ‚â•40% Shield All Dmg");
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [FG ‚â•40%+‚â•50% SHIELD] ${target.name}: +20% DR Offset (direct) + 10% All Dmg (direct)`, "#ec4899");
    }
}

function triggerBoundlessSepal(bdsm) {
    if (bdsm.boundlessTriggers >= 3) return;
    bdsm.boundlessTriggers++;
    log(`&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS SEPAL] Trigger ${bdsm.boundlessTriggers}/3: granting Shield to 3 random allies`, "#ec4899");
    let allies = units.filter(a => a !== bdsm);
    let shuffled = allies.sort(() => Math.random() - 0.5).slice(0, 3);
    shuffled.forEach(a => {
        a.shield = Math.min(100, (a.shield || 0) + 500);
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ ${a.name} gains Shield (500% ATK)`, "#ec4899");
    });
    if (bdsm.boundlessTriggers >= 3) {
        log(`&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS SEPAL] Limit reached!`, "#ec4899");
        if (Math.random() < 0.60) {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ Boss STUNNED for 2 rounds (60% proc)`, "#ec4899");
            }
        boss.ciDebuff = (boss.ciDebuff || 0) + 0.10;
        boss.ciDebuffRounds = 2;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS DEEP SUB] Boss back-line CI -10% for 2 rounds`, "#ec4899");
        units.forEach(a => {
            a.hp = Math.min(100, a.hp + 6);
            addBuff(a, "atk", 0.06, 3, "Boundless Noble Sub");
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BOUNDLESS NOBLE SUB] ${a.name} +6% HP, +6% ATK (3r)`, "#ec4899");
        });
    }
}

function applyLI(source) {
    boss.lethalIncense = true;
    boss.lethalIncenseRounds = 2;
    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Lethal Incense III applied to boss (2 rounds) by ${source}`, "#a78bfa");
}

function applyVoM(target, source) {
    if (!target.veilOfMist) {
        target.veilOfMist = true;
        target.veilOfMistRounds = 2;
        log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Veil of Mist applied to ${target.name} by ${source}`, "#a78bfa");
    }
}

function grantSM(units) {
    let smTarget = units.find(u => u.isM);
    if (!smTarget) return;
    let isRepeat = smTarget.stygianMark;
    smTarget.stygianMark = true;
    if (isRepeat && smTarget.stygianMarkStack < 3) smTarget.stygianMarkStack++;
    else if (!isRepeat) smTarget.stygianMarkStack = 1;
    let bonus = 0.10 * Math.pow(2, smTarget.stygianMarkStack - 1); // 10%‚Üí20%‚Üí40%
    smTarget.buffs.allDmg = smTarget.buffs.allDmg.filter(b => b.source !== "Stygian Mark");
    addBuff(smTarget, "allDmg", bonus, 1, "Stygian Mark");
    log(`&nbsp;&nbsp;&nbsp;üåÄ [FAINT FRAGRANCE] Stygian Mark granted to ${smTarget.name} (stack ${smTarget.stygianMarkStack}: +${(bonus*100).toFixed(0)}% allDmg, 1r)`, "#a78bfa");
}

function expireLI(stv) {
    if (!boss.lethalIncense) return;
    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV LI EXPIRY] Lethal Incense III expires on boss`, "#a78bfa");
    boss.lethalIncense = false;
    if (boss.energy >= 100) {
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ Boss had ‚â•100 energy: loses 100 energy`, "#a78bfa");
        if (Math.random() < 0.5) {
            let candidates = units.filter(u => !u.lethalIncense);
            if (candidates.length > 0) {
                let target = candidates[Math.floor(Math.random() * candidates.length)];
                target.lethalIncense = true;
                target.lethalIncenseRounds = 2;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [LI SPREAD] Lethal Incense spread to ${target.name} (ally) for 2 rounds`, "#a78bfa");
            }
        }
    } else {
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ Boss had <100 energy: takes 30% Max HP damage (capped at 1500% STV ATK)`, "#a78bfa");
        trackStat(stv, "damageDealt", 1500);
    }
}

function triggerFF(actor, stv) {
    if (!actor.stygianMark) return;
    trackStat(stv, "damageDealt", 1500);
    log(`&nbsp;&nbsp;&nbsp;üåÄ [FAINT FRAGRANCE] ${actor.name} (SM) acts ‚Üí LI attack: 1500% ATK cap damage`, "#a78bfa");
    applyLI("Faint Fragrance");
    let lowest = units.reduce((a, b) => a.hp < b.hp ? a : b);
    let heal = (100 - lowest.hp) * 0.15;
    lowest.hp = Math.min(100, lowest.hp + heal);
    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FF] ${lowest.name} +${heal.toFixed(1)}% lost HP restored (now ${lowest.hp.toFixed(1)}%)`, "#a78bfa");

    lowest.shield = Math.min(100, (lowest.shield || 0) + 1000);
    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FF NOBLE SUB] ${lowest.name} gains Shield (1000% ATK)`, "#a78bfa");
}

function tryStarSoul(u) {
    if (!u.hasS) return;
    let triggered = Math.random() < 0.333;
    u.starSoulTally++;
    if (u.starSoulTally >= 3) {
        triggered = true;
        u.starSoulTally = 0;
        log(`&nbsp;&nbsp;&nbsp;üí• [STAR SOUL BURST] ${u.name} guaranteed burst!`, "#f472b6");
    }
    if (triggered) {
        let fastest = units.reduce((a,b) => b.spd > a.spd ? b : a);
        log(`&nbsp;&nbsp;&nbsp;‚≠ê [STAR SOUL SKILL] ${u.name}: +100 to ${fastest.name} (highest SPD), +50 to self`, "#f472b6");
        if (checkC(fastest, "Star Soul +100 Energy", "+100")) fastest.energy += 100;
        if (checkC(u, "Star Soul Self +50", "+50")) u.energy += 50;
    }
}

function triggerPupil(actor) {
    if (!actor.hasPupil) return;
    let maxAtkHero = units.find(u => u.isM) || actor;
    if (checkC(maxAtkHero, "Pupil Dodge +22%")) {
        maxAtkHero.dodge = Math.min(1, maxAtkHero.dodge + 0.22);
        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${maxAtkHero.name} (Max ATK) Dodge +22% (curse-offsettable, resets EoR)`, "#e879f9");
    }
    actor.pupilActionCount++;
    log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${actor.name} action count: ${actor.pupilActionCount}/4`, "#e879f9");
    if (actor.pupilActionCount >= 4) {
        actor.pupilActionCount = 0;
        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL BURST] 4-action threshold! Granting 100% dodge (2 rounds) to low-HP heroes`, "#e879f9");
        units.filter(u => u.isLowHP).forEach(u => {
            u.pupilDodgeRounds = 2;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ‚Üí ${u.name} has 100% dodge for 2 rounds`, "#e879f9");
        });
    }
}

function triggerNova(u) {
    if (!u.hasNova) return;
    u.novaActionCount++;
    // Burn: applied to boss every action
    boss.burn = (boss.burn || 0) + 1;
    log(`&nbsp;&nbsp;&nbsp;üí´ [NOVA BURN] Boss Burn stack ${boss.burn} applied by ${u.name}`, "#fcd34d");
    log(`&nbsp;&nbsp;&nbsp;üí´ [NOVA] ${u.name} action count: ${u.novaActionCount}/4`, "#fcd34d");
    if (u.novaActionCount >= 4) {
        u.novaActionCount = 0;
        if (checkC(u, "Nova Burst", "+100")) u.energy += 100;
        log(`&nbsp;&nbsp;&nbsp;üí´ [NOVA BURST] ${u.name} +100 Energy (offsettable) (now ${u.energy})`, "#fcd34d");
    }
}

function toggleDmgCalc() {
    const panel = document.getElementById('dmgCalcPanel');
    const arrow = document.getElementById('dmgCalcArrow');
    if (panel.style.display === 'none') {
        panel.style.display = 'block';
        arrow.textContent = '‚ñ≤';
    } else {
        panel.style.display = 'none';
        arrow.textContent = '‚ñº';
    }
}

function getDmgCalcInputs() {
    const panel = document.getElementById('dmgCalcPanel');
    if (panel.style.display === 'none' && !window.optimizerContext) return null; // calculator not open = not used
    return {
        atk:    parseFloat(document.getElementById('dc_atk').value)    || 0,
        skill:  parseFloat(document.getElementById('dc_skill').value)  || 0,   // raw %, e.g. 45
        prec:   parseFloat(document.getElementById('dc_prec').value)   || 0,   // raw %, e.g. 150
        holy:   parseFloat(document.getElementById('dc_holy').value)   || 0,   // raw %, e.g. 150
        alldmg: parseFloat(document.getElementById('dc_alldmg').value) || 0,   // raw %, e.g. 800
        crit:   parseFloat(document.getElementById('dc_crit').value)   || 0,   // raw %, e.g. 45
        cd:     parseFloat(document.getElementById('dc_cd').value)     || 150, // raw %, e.g. 150
        defier: document.getElementById('dc_defier').checked,
        gk:     document.getElementById('dc_gk').checked,
        temple: parseFloat(document.getElementById('dc_temple').value) || 0,   // raw %, e.g. 150
    };
}

function runOne(ov = null) {
    window.optimizerContext = !!(ov && ov.fromOptimizer);
    const imp  = document.getElementById('gImp').value;
    const is9  = document.getElementById('isl9').checked;
    const is11 = document.getElementById('isl11').checked;
    const is8  = document.getElementById('isl8').checked;
    const fearGT = document.getElementById('fearGT').checked;
    const safeMode = document.getElementById('safeMode')?.checked || false;
    bossHPTier = document.getElementById('bossHP').value;
    const is10 = document.getElementById('isl10').checked;
    const mIdx = parseInt(document.querySelector('input[name="max"]:checked').value);

    bossHDStacks = 0;
    boss.undyingShadow = false;
    units = [];
    let isl9HDStacks = 0;
    let isl9DRStacks = 6;

    for (let i = 0; i < 6; i++) {
        let art = (ov && ov.heroes) ? ov.heroes[i].art : document.getElementById(`a${i}`).value;
        const heroSpd = (ov && ov.heroes) ? ov.heroes[i].spd : parseInt(document.getElementById(`s${i}`).value);
        const heroIsFr = (ov && ov.heroes) ? ov.heroes[i].isFr : (i < 2);
        units.push({
            pos: i+1,
            name: (ov && ov.heroes && ov.heroes[i].name) ? ov.heroes[i].name : document.getElementById(`h${i}`).value,
            energy: (art === "Demon Bell" || art === "Spiritual Mirror") ? 100 : 50,
            curse: 0, calamity: 0, trans: 0, acts: 0, turnsLost: 0,
            cc: { silence:0, fear:0, seal:0 },
            imm: is11 ? ["silence","fear","seal"][Math.floor(Math.random()*3)] : "none",
            upgradedPurify: (ov && ov.heroes) ? (ov.heroes[i].upgradedPurify || false) : (document.getElementById(`upgPurify${i}`)?.checked || false),
            art: art,
            spd: heroSpd,
            baseCI: (() => {
                const cardIdx = (ov && ov.heroes) ? ov.heroes[i].cardIdx : i;
                const artName = (ov && ov.heroes) ? ov.heroes[i].art : document.getElementById(`a${i}`).value;
                const heroName= (ov && ov.heroes) ? ov.heroes[i].name : document.getElementById(`h${i}`).value;
                const base    = parseFloat(document.getElementById(`ci${cardIdx}`).value) || 0;
                const stellar = (window.optimizerContext ? (ov.heroes[i].voidCI || false) : document.getElementById(`stellar${cardIdx}`)?.checked && STELLAR_HEROES.includes(heroName)) ? 35 : 0;
                const artCI   = artName === 'Spiritual Mirror' ? 20 : artName === 'Scissors' ? 24 : artName === 'Jade Toad' ? 32 : 0;
                const globalCI = (parseFloat(document.getElementById('seTrainCI')?.value) || 0)
                               + (parseFloat(document.getElementById('petCI')?.value) || 0);
                return (base + stellar + artCI + globalCI) / 100;
            })(),
            hasS: (ov && ov.heroes && ov.heroes[i].cardIdx != null) ? document.getElementById(`spec${ov.heroes[i].cardIdx}`).checked : document.getElementById(`spec${i}`).checked,
            fearImm: (() => { const ci = (ov&&ov.heroes) ? ov.heroes[i].cardIdx : i; return document.getElementById(`fearImm${ci}`)?.checked||false; })(),
            sealImm: (() => { const ci = (ov&&ov.heroes) ? ov.heroes[i].cardIdx : i; return document.getElementById(`sealImm${ci}`)?.checked||false; })(),
            silImm:  (() => { const ci = (ov&&ov.heroes) ? ov.heroes[i].cardIdx : i; return document.getElementById(`silImm${ci}`)?.checked||false; })(),

            hasPupil: (ov && ov.heroes && ov.heroes[i].cardIdx != null) ? document.getElementById(`pupil${ov.heroes[i].cardIdx}`).checked : document.getElementById(`pupil${i}`).checked,
            isM: (ov && ov.heroes && ov.heroes[i].cardIdx != null) ? (ov.heroes[i].cardIdx === mIdx) : (i === mIdx), isFr: heroIsFr, bDone: false,
            dodge: (parseInt(document.getElementById(`dg${(ov&&ov.heroes)?ov.heroes[i].cardIdx:i}`).value) || 0) / 100,
            baseDodge: (parseInt(document.getElementById(`dg${(ov&&ov.heroes)?ov.heroes[i].cardIdx:i}`).value) || 0) / 100,
            baseDR:  (parseFloat(document.getElementById(`dr${(ov&&ov.heroes)?ov.heroes[i].cardIdx:i}`).value)  || 0) / 100,
            baseADR: (parseFloat(document.getElementById(`adr${(ov&&ov.heroes)?ov.heroes[i].cardIdx:i}`).value) || 0) / 100,
            starSoulTally: 0,
            pupilActionCount: 0,
            pupilDodgeRounds: 0,
            hasNova: (ov && ov.heroes && ov.heroes[i].cardIdx != null) ? document.getElementById(`nova${ov.heroes[i].cardIdx}`).checked : document.getElementById(`nova${i}`).checked,
            novaActionCount: 0,
            isLowHP: false,
            lbrmSlot1: (i === 0),
            franticGluttony: false,
            franticGluttonyRounds: 0,
            shield: 0,
            infuseUsed: false,
            boundlessTriggers: 0,
            hp: 100,
            stygianMark: false,
            stygianMarkStack: 0,
            transPower: 0,
            brightBlessing: false,
            lethalIncense: false,
            lethalIncenseRounds: 0,
            veilOfMist: false,
            veilOfMistRounds: 0,
            fearAbyssalGaze: false,
            fearAbyssalGazeRounds: 0,
            sourceOfFearProcs: 0,
            powerOfDream: 0,
            dreamMagicWings: false,
            dreamMagicMagnification: false,
            dreamMagicProtection: false,
            mirrorMagicWings: false,
            mirrorMagicMagnification: false,
            mirrorMagicProtection: false,
            shieldLostThisRound: false,
            beeSugarCoat: false,
            fictionalMagic: false,
            fictionalMagicRounds: 0,
            mirrorMagicCount: 3,
            buffs: { atk:[], dr:[], ci:[], spd:[], hd:[], cd:[], crit:[], armor:[], allDmg:[], allDmgReduction:[], drOffset:[], burnBonus:[] },
            jadeToadAllDmg: 0,
            stats: { damageDealt: 0, healingDone: 0 },
            peakCI: 0,
            ciTotal: 0,
            ciSamples: 0,
            fearCIPenalty: 0,
            minDR: Infinity, maxDR: -Infinity, drTotal: 0, drSamples: 0,
            minADR: Infinity, maxADR: -Infinity, adrTotal: 0, adrSamples: 0,
            totalEstDmg: 0,
            dmgPerRound: new Array(15).fill(0)
        });
    }

    boss = { abyssalCorruption: 0, bleed: [], spdDebuff: 0, spiritMirrorRound: 0, atkDebuff: 0, atkDebuffRounds: 0, armorDebuff: 0, armorDebuffRounds: 0, lethalIncense: false, lethalIncenseRounds: 0, veilOfMist: false, veilOfMistRounds: 0, healReduction: 0, healReductionRounds: 0, atkSteal: 0, atkStealRounds: 0, shrink: false, shrinkRounds: 0, burn: 0, watcherMark: 0 };
    let pet = { energy: 0 };

    for (let s = 0; s < 3; s++) {
        let val = document.getElementById(`lowhp${s}`).value;
        if (val !== "") {
            // val is a hero card index (0-5); find unit by name match
            const heroName = document.getElementById(`h${val}`)?.value;
            if (heroName) {
                const u = units.find(u => u.name === heroName);
                if (u) u.isLowHP = true;
            }
        }
    }
    let lowHPNames = units.filter(u => u.isLowHP).map(u => u.name).join(", ");
    let pupilWearers = units.filter(u => u.hasPupil).map(u => u.name).join(", ");
    log(`üëÅÔ∏è PUPIL wearers: ${pupilWearers || "none"} | Low-HP targets: ${lowHPNames || "none"}`, "#e879f9");

    units.filter(u => u.name === "LBRM").forEach(lbrm => {
        lbrm.mirrorMagicWings = true;
        lbrm.mirrorMagicMagnification = true;
        lbrm.mirrorMagicProtection = true;
        lbrm.mirrorMagicCount = 3;
        lbrm.mirrorMagicWingsUsed = false;
        addBuff(lbrm, "ci",     0.08, 999, "Mirror Magic Wings CI");
        addBuff(lbrm, "spd",    0.08, 999, "Mirror Magic Wings SPD");
        addBuff(lbrm, "allDmg", 0.10, 999, "Mirror Magic Magnification allDmg");
        addBuff(lbrm, "dr",     0.18, 999, "Mirror Magic Deep Sub DR (3√ó6%)");
        log(`[LBRM INIT] Dreamlike Illusion: 3 Mirror Magic (+8%CI +8%SPD +10%allDmg +18%DR)`, "#f0abfc");
    });

    // DGN battle start
    if (units.find(u => u.name === "DGN")) initDGN(units);

    units.forEach(u => {
        if (u.name === "SQH") {
            log(`üëë [SQH ROYAL GUARD] Granting +24% All-Damage to all allies at battle start`, "#f59e0b");
            units.filter(a => a !== u).forEach(a => {
                addBuff(a, "allDmg", 0.24, 999, "SQH Royal Guard");
                addBuff(a, "allDmgReduction", 0.08, 999, "SQH Royal Guard ADR");
            });
            log(`üëë [SQH ROYAL GUARD] All allies +24% allDmg, +8% ADR (permanent)`, "#f59e0b");
        }
    });

    units.forEach(u => {
        if (u.hasS) {
            log(`üîÆ ${u.name} Specter Battle-Start`);
            if (checkC(u, "Spec Start Self", "+50")) u.energy += 50;
            let randAlly = units[Math.floor(Math.random() * units.length)];
            if (checkC(randAlly, "Spec Start Team", "+50")) randAlly.energy += 50;
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BATTLE START CI BONUSES (permanent, non-offsettable)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    log(``, "#fff");
    log(`‚öîÔ∏è ‚ïê‚ïê‚ïê BATTLE START CI BONUSES ‚ïê‚ïê‚ïê`, "#facc15");
    units.forEach(u => {
        // 1. Team CI bonus: flat +15% to all heroes
        u.buffs.ci.push({ value: 0.12, rounds: 999, source: "Team CI Bonus" });
        let teamTotal = u.baseCI + getBuffTotal(u, "ci");
        log(`&nbsp;&nbsp;&nbsp;üí† [TEAM CI BONUS] ${u.name} +12% CI (permanent) | Eff. CI now: ${(teamTotal*100).toFixed(1)}%`, "#facc15");

        // 2. Sub-100% pre-battle CI bonus: 20% of remainder below 100%
        if (u.baseCI < 1.0) {
            let remainder = 1.0 - u.baseCI;
            let bonus = remainder * 0.20;
            u.buffs.ci.push({ value: bonus, rounds: 999, source: "Sub-100 CI Bonus" });
            // If Fear Guild Train is OFF, this bonus doesn't apply to fear resistance
            u.fearCIPenalty = fearGT ? 0 : bonus;
            let newTotal = u.baseCI + getBuffTotal(u, "ci");
            let fearNote = fearGT ? "" : ` | ‚ö†Ô∏è Fear CI: ${((newTotal - bonus)*100).toFixed(1)}% (GT off)`;
            log(`&nbsp;&nbsp;&nbsp;üí† [SUB-100 CI BONUS] ${u.name} pre-battle CI ${(u.baseCI*100).toFixed(0)}% < 100% ‚Üí remainder ${(remainder*100).toFixed(1)}% √ó 20% = +${(bonus*100).toFixed(1)}% CI (permanent) | Eff. CI now: ${(newTotal*100).toFixed(1)}%${fearNote}`, "#facc15");
        }
    });
    log(`‚öîÔ∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, "#facc15");
    log(``, "#fff");

    // Apply pre-battle DR and ADR as permanent buffs
    units.forEach(u => {
        if (u.baseDR > 0) {
            u.buffs.dr.push({ value: u.baseDR, rounds: 999, source: "Pre-Battle DR" });
            log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è [PRE-BATTLE DR] ${u.name} +${(u.baseDR*100).toFixed(0)}% DR (permanent)`, "#94a3b8");
        }
        if (u.baseADR > 0) {
            u.buffs.allDmgReduction.push({ value: u.baseADR, rounds: 999, source: "Pre-Battle ADR" });
            log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è [PRE-BATTLE ADR] ${u.name} +${(u.baseADR*100).toFixed(0)}% All DMG Reduction (permanent)`, "#94a3b8");
        }
    });

    let shrinkMissedRound = false;
    for (let r = 1; r <= 15; r++) {
        log(`ROUND ${r}`, "#ff4757");

        // ‚îÄ‚îÄ Pet activation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (pet.energy >= 100) {
            pet.energy = 0;
            log(`&nbsp;&nbsp;&nbsp;üêæ [PET ACTIVATE] Energy ‚â•100 ‚Äî burst! Gives +80% burn bonus dmg to 4 heroes (3r)`, "#a78bfa");
            // Pick 4 random heroes
            const shuffled = [...units].sort(() => Math.random() - 0.5);
            shuffled.slice(0, 4).forEach(h => {
                addBuff(h, "burnBonus", 0.80, 3, "Pet Burn Bonus");
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üêæ ${h.name} +80% burn bonus dmg (3r)`, "#a78bfa");
            });
        }

        units.forEach(u => { if (u.pupilDodgeRounds > 0) u.pupilDodgeRounds--; });

        if (is9) {
            if (isl9DRStacks > 0) {
                isl9DRStacks--;
                units.forEach(u => {
                    let idx = u.buffs.allDmgReduction.findIndex(b => b.source === "Island 9 DR start" || b.source === "Island 9 DR");
                    if (idx >= 0) u.buffs.allDmgReduction.splice(idx, 1);
                    addBuffSilent(u, "allDmgReduction", isl9DRStacks * 0.10, 999, "Island 9 DR");
                });
                log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL9] allDmgReduction now ${(isl9DRStacks*10)}% (all allies)`, "#a78bfa");
            }
            isl9HDStacks++;
            log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL9] Holy Dmg now ${(isl9HDStacks*10)}%`, "#a78bfa");
        }
        if (is10) {
            units.forEach(u => addBuffSilent(u, "allDmg", 0.25, 2, "Island 10"));
            log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL10] All allies +25% allDmg (2r, silent)`, "#a78bfa");
        }

        let lbrmHero = units.find(x => x.name === "LBRM" && x.cc.seal <= 0);
        if (lbrmHero) {
            units.forEach(ally => {
                if (ally.hp < 30 && lbrmHero.energy >= 30) {
                    lbrmHero.energy -= 30;
                    lbrmHero.powerOfDream = Math.min(3, lbrmHero.powerOfDream + 1);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON] ${ally.name} HP<30% ‚Üí Shield 2000% ATK granted, LBRM PoD=${lbrmHero.powerOfDream}`, "#f0abfc");
                }
            });
        }

        let stv = units.find(u => u.name === "STV");
        if (stv) grantSM(units);

        // DGN transition at end of round
        { const dgn = units.find(u => u.name === "DGN");
          if (dgn) fireDGNTransition(dgn, r); }

        units.forEach(u => {
            u.infuseUsed = false;
            u.boundlessTriggers = 0;
            if (u.franticGluttony) {
                u.franticGluttonyRounds--;
                if (u.franticGluttonyRounds <= 0) {
                    u.franticGluttony = false;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] ${u.name} Frantic Gluttony expired`, "#ec4899");
                }
            }
        });

        units.forEach(u => {
            if (u.energy >= 100) checkC(u, "Round Start ATK Buff (Energy ‚â•100)", "+30%");
        });

        units.forEach(u => {
            u.bDone = false;
            if (u.name === "STV") {
                if (u.trans >= 12) {
                    u.trans -= 12;
                    log(`&nbsp;&nbsp;&nbsp;üíé [STV MOON ABYSS 12-STACK]`, "#a78bfa");
                    trackStat(u, "damageDealt", 1500);
                    applyLI("STV Moon Abyss 12-stack");
                    boss.atkDebuff = (boss.atkDebuff || 0) + 0.20; boss.atkDebuffRounds = 2;
                    boss.armorDebuff = (boss.armorDebuff || 0) + 0.20; boss.armorDebuffRounds = 2;
                    boss.drDebuff = (boss.drDebuff || 0) + 0.20; boss.drDebuffRounds = 2;
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.20; boss.ciDebuffRounds = 2;
                    boss.spdDebuff = (boss.spdDebuff || 0) + 100;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV 12-STACK] Boss: -20% ATK/Armor/DR/CI, -100 SPD (2r)`, "#a78bfa");
                    units.forEach(a => {
                        let bonus = a.stygianMark ? 0.20 : 0.10;
                        addBuff(a, "allDmg", bonus, 2, "STV Moon Abyss 12-stack");
                    });
                    let smAlly = units.find(a => a.isM);
                    if (smAlly) addBuff(smAlly, "allDmg", 0.10, 2, "STV Acheron Barque");
                    boss.healReduction = 0.80; boss.healReductionRounds = 3;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduced 80% for 3 rounds`, "#a78bfa");
                    addBuff(u, "allDmg", 0.15, 2, "STV Sun Halo");
                    units.forEach(a => { if (checkC(a, "STV Glowed Glory +20", "+20")) a.energy += 20; });
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV GLOWED GLORY] +20 Energy to all (curse-offsettable)`, "#a78bfa");
                } else if (u.trans >= 6) {
                    u.trans -= 6;
                    log(`&nbsp;&nbsp;&nbsp;üíé [STV 6-STACK TRANSITION]`, "#a78bfa");
                    trackStat(u, "damageDealt", 1500);
                    applyLI("STV 6-stack");
                    let smAlly = units.find(a => a.isM);
                    if (smAlly) addBuff(smAlly, "allDmg", 0.10, 2, "STV Acheron Barque");
                    boss.healReduction = 0.80; boss.healReductionRounds = 3;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduced 80% for 3 rounds`, "#a78bfa");
                    addBuff(u, "allDmg", 0.15, 2, "STV Sun Halo");
                    units.forEach(a => { if (checkC(a, "STV Glowed Glory +20", "+20")) a.energy += 20; });
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV GLOWED GLORY] +20 Energy to all (curse-offsettable)`, "#a78bfa");
                }
            }
        });

        let ord = [...units].sort((a,b) => b.spd - a.spd);
        ord.forEach(u => {
            let sealed = u.cc.seal > 0;
            let silenced = u.cc.silence > 0;
            log(`--- ${u.name} Moves (Nrg: ${u.energy}, Dodge: ${Math.round(u.dodge*100)}%) ---`);

            if (u.cc.fear > 0 || u.cc.silence > 0 || u.cc.seal > 0) {
                log(`&nbsp;&nbsp;&nbsp;‚ö†Ô∏è CC ACTIVE: ${u.cc.fear>0?'FEAR ':''}${u.cc.silence>0?'SILENCE ':''}${u.cc.seal>0?'SEAL':''}`, "#ef4444");
            }

            if (u.name === "BDSM" && u.energy >= 100 && !u.bDone && !silenced) {
                log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è [BDSM THRESHOLD] Backline CI +15% (2r) + ADR +8% (2r)`, "#ec4899");
                units.forEach(t => {
                    if (!t.isFr) {
                        if (t.curse > 0) {
                            t.curse--;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ú® [CURSE OFFSET] ${t.name}: BDSM Threshold CI +15%`, "#fbbf24");
                        } else {
                            refreshBuff(t, "ci", 0.15, 2, "BDSM Threshold CI");
                        }
                        refreshBuff(t, "allDmgReduction", 0.08, 2, "BDSM Threshold ADR");
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM THRESHOLD] ${t.name} +8% ADR (2r)`, "#ec4899");
                    }
                });
                u.bDone = true;
            }

            let didHitBoss = false;
            let usedBasic = false;
            let usedActive = false;

            if (u.energy >= 100 && u.cc.silence <= 0) {
                u.energy = 0; u.trans += 6; u.acts++; didHitBoss = true; usedActive = true;
                log(`üî• ACTION: Active`);

                units.forEach(target => {
                    if (target.name === "BDSM" && u.name !== "BDSM" && target.cc.seal <= 0) {
                        if (checkC(target, "BDSM Passive Energy", "+3")) target.energy += 3;
                        if (u.franticGluttony) {
                            let lostHp = 100 - target.hp;
                            let heal = lostHp * 0.10;
                            target.hp = Math.min(100, target.hp + heal);
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [FG TRIGGER] ${u.name} acted with FG ‚Üí BDSM +${heal.toFixed(1)}% HP (now ${target.hp.toFixed(1)}%)`, "#ec4899");
                            triggerBoundlessSepal(target);
                        }
                    }
                });
                { let stvHero = units.find(s => s.name === "STV");
                  if (stvHero && u.stygianMark && u.name !== "STV") triggerFF(u, stvHero); }
                if (u.name === "STV") {
                    trackStat(u, "damageDealt", 1500);
                    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV SOULCALL] 1500% ATK damage dealt`, "#a78bfa");
                    applyLI("Soulcall");
                    boss.spdDebuff = (boss.spdDebuff || 0) + 50; boss.spdDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV DEEP SUB] Boss SPD -50 (2r)`, "#a78bfa");
                    boss.atkDebuff = (boss.atkDebuff || 0) + 0.20; boss.atkDebuffRounds = 2;
                    boss.armorDebuff = (boss.armorDebuff || 0) + 0.20; boss.armorDebuffRounds = 2;
                    boss.drDebuff = (boss.drDebuff || 0) + 0.20; boss.drDebuffRounds = 2;
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.20; boss.ciDebuffRounds = 2;
                    boss.spdDebuff = (boss.spdDebuff || 0) + 100;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV SOULCALL] Boss: -20% ATK/Armor/DR/CI, -100 SPD (2r)`, "#a78bfa");
                    units.forEach(a => {
                        let isSM = a.stygianMark;
                        let mult = isSM ? 2 : 1;
                        tryBuff(a, "atk",   0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "dr",    0.10 * mult, 2, "STV Soulcall");
                        refreshBuff(a, "ci", 0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "armor", 0.10 * mult, 2, "STV Soulcall");
                        tryBuff(a, "spd",   (isSM ? 0.60 : 0.30), 2, "STV Soulcall SPD");
                        if (isSM) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [SM BONUS] ${a.name} gets 2√ó buffs from Soulcall`, "#a78bfa");
                    });
                    triggerFF(u, u);
                }
                if (u.name === "SQH") {
                    let dmg = 1800;
                    trackStat(u, "damageDealt", dmg);
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] ${dmg}% ATK damage dealt`, "#f59e0b");
                    boss.bleed.push({ dmg: 1800, rounds: 2 });
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] Bleed applied (1800% ATK/round for 2 rounds)`, "#f59e0b");
                    boss.abyssalCorruption++;
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH CRIMSON ABYSS] Abyssal Corruption: ${boss.abyssalCorruption} layer(s) | Boss takes +${(boss.abyssalCorruption*24).toFixed(0)}% Crit DMG`, "#f59e0b");
                    if (Math.random() < 0.25) {
                        boss.abyssalCorruption++;
                        log(`&nbsp;&nbsp;&nbsp;üëë [SQH NOBLE SUB] Extra Corruption layer! Total: ${boss.abyssalCorruption} | Boss takes +${(boss.abyssalCorruption*24).toFixed(0)}% Crit DMG`, "#f59e0b");
                    }
                }
                if (u.name === "BDSM") {
                    trackStat(u, "damageDealt", 3000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM TIME TO FEAST] 3000% ATK damage dealt`, "#ec4899");
                    boss.ciDebuff = (boss.ciDebuff || 0) + 0.15;
                    boss.ciDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Boss CI -15% for 2 rounds`, "#ec4899");
                    u.hp = Math.min(100, u.hp + 25);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Self +25% Max HP restored (now ${u.hp}%)`, "#ec4899");
                    triggerBoundlessSepal(u);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE] Granting Frantic Gluttony to shielded allies`, "#ec4899");
                    units.filter(a => a !== u).forEach(a => { grantFG(a, u); });
                    if (Math.random() < 0.4) {
                        units.forEach(a => { if (checkC(a, "BDSM Active Team Energy", "+10")) a.energy += 10; });
                    }
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM CORE LIBERATION] 5 allies all thresholds met`, "#ec4899");
                    for (let tick = 0; tick < 5; tick++) { units.forEach(a => { trackStat(a, "healingDone", 500); }); }
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•30%] 5 ticks: all allies +2500% ATK healing total`, "#ec4899");
                    // 5 CI ticks ‚Äî refresh (clear old CL CI stacks first, then apply fresh 5)
                    units.forEach(a => {
                        a.buffs.ci = a.buffs.ci.filter(b => !b.source.startsWith("Core Liberation CI"));
                    });
                    for (let tick = 0; tick < 5; tick++) {
                        units.forEach(a => {
                            if (a.curse > 0) { a.curse--; } // curse offsets each tick individually
                            else { addBuffSilent(a, "ci", 0.045, 2, `Core Liberation CI tick ${tick+1}`); }
                        });
                    }
                    units.forEach(a => {
                        let applied = a.buffs.ci.filter(b => b.source.startsWith("Core Liberation CI")).length;
                        let total = getBuffTotal(a, "ci");
                        if (applied > 0) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•40%] ${a.name} +${(applied*4.5).toFixed(1)}% CI (${applied} ticks refreshed, 2r) | Eff. CI: ${((a.baseCI+total)*100).toFixed(0)}%`, "#ec4899");
                    });
                    // 5 allDmg ticks ‚Äî apply silently then log summary per hero
                    for (let tick = 0; tick < 5; tick++) {
                        units.forEach(a => { addBuffSilent(a, "allDmg", 0.045, 2, `Core Liberation allDmg tick ${tick+1}`); });
                    }
                    units.forEach(a => {
                        let applied = a.buffs.allDmg.filter(b => b.source.startsWith("Core Liberation allDmg")).length;
                        let total = getBuffTotal(a, "allDmg");
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [CORE LIB ‚â•50%] ${a.name} +${(applied*4.5).toFixed(1)}% allDmg (${applied} ticks, 2r) | Total allDmg: +${(total*100).toFixed(0)}%`, "#ec4899");
                    });
                    const bdsmCCTypes = ["silence","fear","seal"];
                    units.forEach(a => {
                        let activeCC = bdsmCCTypes.filter(t => a.cc[t] > 0);
                        if (activeCC.length > 0) {
                            let rem = activeCC[Math.floor(Math.random() * activeCC.length)];
                            a.cc[rem] = 0;
                            log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM ACTIVE CC CLEANSE] ${a.name}: ${rem} removed`, "#ec4899");
                        }
                    });
                    boss.allDmgReductionDebuff = (boss.allDmgReductionDebuff || 0) + 0.10;
                    boss.allDmgReductionDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM NOBLE SUB] Boss All-damage Reduction -10% for 2 rounds`, "#ec4899");
                }
                if (u.name === "LBRM") {
                    let frontline = units.filter(a => a.isFr);
                    trackStat(u, "damageDealt", 2400);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM DREAMLAND DOMINION] 2400% ATK to frontline`, "#f0abfc");
                    let dmDur = 4;
                    frontline.forEach(a => {
                        a.buffs.dr.push({ value: -0.15, rounds: dmDur, source: "DD Frontline DR debuff" });
                        a.buffs.ci.push({ value: -0.15, rounds: dmDur, source: "DD Frontline CI debuff" });
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${a.name} DR -15%, CI -15% (${dmDur}r)`, "#f0abfc");
                    });
                    units.filter(a => !a.isFr).forEach(a => {
                        a.buffs.dr.push({ value: -0.15, rounds: dmDur, source: "DD Backline DR debuff (Deep sub)" });
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD DEEP SUB] ${a.name} DR -15% (${dmDur}r)`, "#f0abfc");
                    });
                    function grantDreamMagic(target, type) {
                        if (type === "Wings"          && target.mirrorMagicWings)         { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Wings ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Magnification"  && target.mirrorMagicMagnification) { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Magnification ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Protection"     && target.mirrorMagicProtection)    { log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} already has Mirror Magic Protection ‚Äî skip`, "#f0abfc"); return; }
                        if (type === "Wings") {
                            target.dreamMagicWings = true;
                            refreshBuff(target, "ci", 0.10, dmDur, "Dream Magic Wings CI");
                            refreshBuff(target, "spd", 0.10, dmDur, "Dream Magic Wings SPD");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Wings (+10%CI, +10%SPD, ${dmDur}r)`, "#f0abfc");
                        }
                        if (type === "Magnification") {
                            target.dreamMagicMagnification = true;
                            tryBuff(target, "allDmg", 0.12, dmDur, "Dream Magic Magnification");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Magnification (+12%allDmg, ${dmDur}r)`, "#f0abfc");
                        }
                        if (type === "Protection") {
                            target.dreamMagicProtection = true;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD] ${target.name} ‚Üí Dream Magic Protection (Shield 3000% ATK, ${dmDur}r)`, "#f0abfc");
                        }
                    }
                    let highestSPD = units.reduce((a, b) => (a.spd > b.spd ? a : b));
                    let highestATK = units.find(u2 => u2.isM) || units[0];
                    let slot1Hero  = units.find(a => a.lbrmSlot1) || units[0];
                    grantDreamMagic(highestSPD, "Wings");
                    grantDreamMagic(highestATK, "Magnification");
                    grantDreamMagic(slot1Hero,  "Protection");
                    u.powerOfDream = 0;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream consumed ‚Üí reset to 0`, "#f0abfc");
                }
                if (u.name === "LFA") {
                    // Hit 1-2: always (2√ó1200%)
                    let hits12 = 2400;
                    trackStat(u, "damageDealt", hits12);
                    log(`&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] Hits 1-2: ${hits12}% ATK (2√ó1200%, always)`, "#c084fc");
                    // Hit 3-4: only if boss HP < 60%
                    let hits34 = 0;
                    if (bossHPTier === "below50" || bossHPTier === "50-59") {
                        hits34 = 2400;
                        trackStat(u, "damageDealt", hits34);
                        trackStat(u, "healingDone", hits34 * 1.20);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] Hits 3-4: ${hits34}% ATK (2√ó1200%, boss HP<60%), self heal ${(hits34*1.20).toFixed(0)}% ATK`, "#c084fc");
                    } else {
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] Hits 3-4: skipped (boss HP‚â•60%)`, "#c084fc");
                    }
                    // DKM: 120% of hits 1-4 (boss always fear-immune)
                    let dkmBonus = Math.round((hits12 + hits34) * 1.20);
                    trackStat(u, "damageDealt", dkmBonus);
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [DKM] Boss fear-immune: 120% of hits 1-4 (${hits12+hits34}%) = ${dkmBonus}% ATK`, "#c084fc");
                    // Hit 5: always (1√ó1200%), after DKM
                    let hit5 = 1200;
                    trackStat(u, "damageDealt", hit5);
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA SOUL SHIVER] Hit 5: ${hit5}% ATK (always)`, "#c084fc");
                    if (checkC(u, "LFA DKM ATK Steal")) {
                        boss.atkSteal = (boss.atkSteal || 0) + 0.30;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [DKM ATK STEAL] -${(boss.atkSteal*100).toFixed(0)}% boss ATK (cumulative, curse-offsettable)`, "#c084fc");
                    }
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA TOTAL] ${hits12 + hits34 + dkmBonus + hit5}% ATK total this active`, "#c084fc");
                    // ‚îÄ‚îÄ Damage Calculator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    const dc = getDmgCalcInputs();
                    if (dc) {
                        const atkBuff     = getBuffTotal(u, "atk");
                        const allDmgBuff  = getBuffTotal(u, "allDmg");
                        const holyBuff    = dc.holy / 100 + getBuffTotal(u, "hd");   // user base + in-fight gains
                        const critBuff    = dc.crit / 100 + getBuffTotal(u, "crit"); // user base + in-fight gains
                        const precCapped  = Math.min(dc.prec / 100, 1.50);
                        const cdCapped    = Math.min(dc.cd / 100 + getBuffTotal(u, "cd"), 1.50); // capped 150%
                        const corrMult    = 1 + 0.24 * (boss.abyssalCorruption || 0);
                        const critMult    = 1.5 * cdCapped * 2 * corrMult;
                        const gkMult      = dc.gk ? 2.0 : 1.0;
                        const defMult     = (dc.defier && bossHPTier === "above70") ? 1.3 : 1.0;
                        const templeMult  = 1 + dc.temple / 100; // e.g. 150% ‚Üí dc.temple=150 ‚Üí templeMult=2.5
                        const shrinkMult  = boss.shrink ? 1.4 : 1.0;
                        const allDmgMult  = 1 + allDmgBuff + dc.alldmg / 100; // dc.alldmg raw %, allDmgBuff already decimal

                        // Per-hit base formula (one hit of X% multiplier)
                        function calcHit(multPct) {
                            const base = dc.atk
                                * (1 + atkBuff)
                                * ((multPct + (dc.skill + antlersSkill) / 100))
                                * (1 + precCapped * 0.3)
                                * (1 + (dc.holy / 100) * 0.7)
                                * allDmgMult
                                * gkMult * defMult * templeMult * shrinkMult;
                            const isCrit = Math.random() < (dc.crit / 100);
                            return isCrit ? base * critMult : base;
                        }

                              // ‚îÄ‚îÄ Damage calculation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        let anyCritMiss = false;
                        let hits14Sum = 0; // sum of fully calculated hits 1-4 (for DKM)
                        const antiwarriorMult = (u.art === "Antiwarrior") ? 1.90 : 1.0;
                        const antlersSkill    = (ov && ov.fromOptimizer) ? (u.art === "Antlers" ? 300 : u.art === "Antiwarrior" ? 50 : 0) : 0; // optimizer only
                        const watcherMarkMult  = 1 + (boss.watcherMark || 0); // e.g. 300% ‚Üí √ó4
                        const burnBonusMult    = (boss.burn > 0) ? 1 + getBuffTotal(u, "burnBonus") : 1.0; // only vs burn targets
                        function calcHitTracked(multPct) {
                            const base = dc.atk
                                * (1 + atkBuff)
                                * (multPct + dc.skill / 100)
                                * (1 + precCapped * 0.3)
                                * (1 + holyBuff * 0.7)
                                * allDmgMult * gkMult * defMult * templeMult * shrinkMult
                                * antiwarriorMult * watcherMarkMult * burnBonusMult;
                            const isCrit = Math.random() < (critBuff + 0.10); // LFA active +10% crit
                            if (!isCrit) anyCritMiss = true;
                            return isCrit ? base * critMult : base;
                        }
                        const modMult = allDmgMult * gkMult * defMult * templeMult * shrinkMult;
                        let hitLog = []; let totalDmg = 0;
                        let srcHits = 0, srcDKM = 0, srcLethal = 0, srcBS = 0, srcAddl = 0;

                        // Hits 1-2 (always)
                        for (let h = 1; h <= 2; h++) {
                            const d = calcHitTracked(12); totalDmg += d; hits14Sum += d;
                            hitLog.push(`Hit ${h}: ${Math.round(d).toLocaleString()}`);
                        }
                        // Hits 3-4 (boss below 60%)
                        if (bossHPTier === 'below50' || bossHPTier === '50-59') {
                            for (let h = 3; h <= 4; h++) {
                                const d = calcHitTracked(12); totalDmg += d; hits14Sum += d;
                                hitLog.push(`Hit ${h}: ${Math.round(d).toLocaleString()}`);
                            }
                        }
                        srcHits += totalDmg; // hits 1-4 damage before DKM and hit 5

                        // DKM: 120% of fully calculated hits 1-4 √ó modMult
                        const dkmDmgCalc = hits14Sum * 1.20 * modMult;
                        srcDKM = dkmDmgCalc;
                        totalDmg += dkmDmgCalc;
                        hitLog.push(`DKM (120% of hits 1-4 √ó modMult): ${Math.round(dkmDmgCalc).toLocaleString()}`);

                        // Hit 5 (always)
                        const d5 = calcHitTracked(12); totalDmg += d5; srcHits += d5;
                        hitLog.push(`Hit 5: ${Math.round(d5).toLocaleString()}`);

                        const initialPlusDKM = totalDmg;

                        // ‚îÄ‚îÄ Lethal Fightback: 18% of (hits 1-5 + DKM) √ó modMult ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        const lethalFB = initialPlusDKM * 0.18 * modMult;
                        srcLethal = lethalFB;
                        totalDmg += lethalFB;
                        hitLog.push(`Lethal Fightback (18%): ${Math.round(lethalFB).toLocaleString()}`);

                        // ‚îÄ‚îÄ Balanced Strike: fires if any hit did NOT crit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        if (anyCritMiss) {
                            const bsPct = bossHPTier === 'below50' ? 1.95 : 0.45;
                            srcBS = initialPlusDKM * bsPct * modMult;
                            totalDmg += srcBS;
                            hitLog.push(`Balanced Strike (${(bsPct*100).toFixed(0)}%, non-crit): ${Math.round(srcBS).toLocaleString()}`);
                        } else {
                            hitLog.push(`Balanced Strike: skipped (all hits crit)`);
                        }

                        // ‚îÄ‚îÄ Additional Multiplier: 80% proc, not sealed, 10% of all prior ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        if (u.cc.seal <= 0 && Math.random() < 0.80) {
                            srcAddl = (initialPlusDKM + lethalFB + srcBS) * 0.10 * modMult;
                            totalDmg += srcAddl;
                            hitLog.push(`Additional Multiplier (80% proc, 10%): ${Math.round(srcAddl).toLocaleString()}`);
                        } else {
                            hitLog.push(`Additional Multiplier: ${u.cc.seal > 0 ? 'blocked (sealed)' : 'did not proc (20%)'}`);
                        }

                        // Accumulate per-source damage on unit
                        u.srcHits   = (u.srcHits   || 0) + srcHits;
                        u.srcDKM    = (u.srcDKM    || 0) + srcDKM;
                        u.srcLethal = (u.srcLethal || 0) + srcLethal;
                        u.srcBS     = (u.srcBS     || 0) + srcBS;
                        u.srcAddl   = (u.srcAddl   || 0) + srcAddl;

                        log(`&nbsp;&nbsp;&nbsp;‚öîÔ∏è [DMG CALC] ATK:${dc.atk.toLocaleString()} | ATKbuff:+${(atkBuff*100).toFixed(0)}% | Skill:+${(dc.skill + antlersSkill).toFixed(0)}%${antlersSkill===300?" (incl +300 Antlers)":antlersSkill===50?" (incl +50 Antiwarrior)":""} | Prec:${dc.prec.toFixed(0)}% | Holy:${(holyBuff*100).toFixed(0)}% (base ${dc.holy.toFixed(0)}%+fight ${(getBuffTotal(u,'hd')*100).toFixed(0)}%) | AllDmg:+${(allDmgMult*100-100).toFixed(0)}% | Crit:${(critBuff*100).toFixed(1)}%@${(cdCapped*100).toFixed(0)}%CD | GK:${dc.gk?'‚úì':'‚úó'} Def:${defMult>1?'‚úì':'‚úó'} Temple:√ó${templeMult.toFixed(2)} Shrink:${boss.shrink?'‚úì':'‚úó'} AbyssalCorruption:${boss.abyssalCorruption||0}${antiwarriorMult>1?' | Antiwarrior:√ó1.90':''} | WatcherMark:√ó${watcherMarkMult.toFixed(2)} | BurnBonus:√ó${burnBonusMult.toFixed(2)}`, '#facc15');
                        log('&nbsp;&nbsp;&nbsp;‚öîÔ∏è [HIT FORMULA] ATK √ó (1+ATKbuff) √ó (hitMult%+Skill%) √ó (1+min(Prec,150%)√ó0.3) √ó (1+Holy√ó0.7) √ó (1+AllDmg) √ó GK √ó Defier √ó Temple √ó Shrink' + (antiwarriorMult>1?' √ó Antiwarrior(1.9)':'') + ` √ó WatcherMark(${watcherMarkMult.toFixed(2)})` + ' ‚Üí √óCritMult if crit', '#94a3b8');
                        log(`&nbsp;&nbsp;&nbsp;‚öîÔ∏è [HIT FORMULA VALUES] ATK:${dc.atk.toLocaleString()} √ó (1+${(atkBuff*100).toFixed(0)}%) √ó (12+${dc.skill.toFixed(0)}%) √ó (1+${(precCapped*100).toFixed(0)}%√ó0.3=${(1+precCapped*0.3).toFixed(3)}) √ó (1+${(holyBuff*100).toFixed(0)}%√ó0.7=${(1+holyBuff*0.7).toFixed(3)}) √ó ${allDmgMult.toFixed(3)} √ó ${gkMult} √ó ${defMult} √ó ${templeMult.toFixed(3)} √ó ${shrinkMult}${antiwarriorMult>1?' √ó 1.9':''} √ó ${watcherMarkMult.toFixed(2)}(WM) ‚Üí CritMult: 1.5√ó${(cdCapped*100).toFixed(0)}%√ó2√ó${corrMult.toFixed(2)}=${critMult.toFixed(3)}`, '#94a3b8');
                        hitLog.forEach(h => log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚öîÔ∏è ${h}`, '#facc15'));
                        log(`&nbsp;&nbsp;&nbsp;‚öîÔ∏è [DMG CALC TOTAL] ${Math.round(totalDmg).toLocaleString()} damage this active`, '#facc15');                       u.totalEstDmg += totalDmg;
                    if (u.dmgPerRound) u.dmgPerRound[r-1] = (u.dmgPerRound[r-1]||0) + totalDmg;
                    }
                }
                if (u.name === "DGN") {
                    fireDGNActive(u, true, r);
                    u.transPower = (u.transPower || 0) + 6;
                    log(`&nbsp;&nbsp;&nbsp;üåë [DGN PHANTOM DAWN] +6 Transition Power ‚Üí ${u.transPower}`, "#c084fc");
                }
                if (u.name === "ELY") {
                    boss.shrink = true;
                    boss.shrinkRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üåä [ELY ACTIVE] Boss Shrink applied (2r, √ó1.4 dmg)`, "#38bdf8");
                }
                if (u.name === "HW") {
                    const prev = boss.watcherMark || 0;
                    boss.watcherMark = Math.min(3.0, prev + 0.45);
                    log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [HW ACTIVE] Watcher Mark +45% ‚Üí ${(boss.watcherMark*100).toFixed(0)}% (cap 300%)`, "#38bdf8");
                }
                if (u.art === "Demon Bell") {
                    units.forEach(a => {
                        if (checkC(a, "DB Energy", "+20")) a.energy += 20;
                        if (Math.random() < 0.5) {
                            if (checkC(a, "DB Bonus", "+10")) a.energy += 10;
                        }
                        if (a.energy >= 100) {
                            tryBuff(a, "spd", 0.09, 4, "Demon Bell Full Energy SPD");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üéµ [DB] ${a.name} at full energy: +9 SPD (4r)`, "#38bdf8");
                        }
                    });
                }
                if ((u.dreamMagicMagnification || u.mirrorMagicMagnification)) {
                    trackStat(u, "damageDealt", 3000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [MAGNIFICATION] ${u.name} extra 15% target Max HP dmg (capped 3000% ATK)`, "#f0abfc");
                }
                if (is8) {
                    units.forEach(a => addBuffSilent(a, "allDmg", 0.03, 999, "Island 8 active proc"));
                    log(`&nbsp;&nbsp;&nbsp;üèùÔ∏è [ISL8] ${u.name} active ‚Üí all allies +3% allDmg (permanent, now stacked ${u.acts}√ó)`, "#a78bfa");
                }
                tryStarSoul(u);
                triggerPupil(u);
                triggerNova(u);
                if (u.name === "BDSM" && !u.infuseUsed) {
                    u.infuseUsed = true;
                    if (u.hp >= 70) {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP ‚â•70% (${u.hp.toFixed(1)}%): -60% HP, granting Shield+CI to self & backline`, "#ec4899");
                        u.hp = Math.max(0, u.hp - 60);
                        units.filter(a => !a.isFr || a === u).forEach(a => {
                            a.shield = Math.min(100, (a.shield || 0) + 40);
                            refreshBuff(a, "ci", 0.15, 2, "BDSM Infuse with Flavor");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [INFUSE] ${a.name} Shield +40% MaxHP, CI +15% (2r)`, "#ec4899");
                        });
                        triggerBoundlessSepal(u);
                    } else {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP <70% (${u.hp.toFixed(1)}%): restoring 15% HP + Shield`, "#ec4899");
                        u.hp = Math.min(100, u.hp + 15);
                        u.shield = Math.min(100, (u.shield || 0) + 15);
                        triggerBoundlessSepal(u);
                    }
                }

            } else if (u.cc.fear <= 0) {
                u.energy += 50; didHitBoss = true; usedBasic = true;
                log(`‚öîÔ∏è ACTION: Basic Attack`);
                log(`&nbsp;&nbsp;&nbsp;‚ö° Basic Attack self energy: +50 (direct)`, "#4ade80");

                if (u.franticGluttony && u.name !== "BDSM") {
                    let bdsm = units.find(b => b.name === "BDSM");
                    if (bdsm) {
                        if (checkC(bdsm, "BDSM Passive Energy (FG Basic)", "+3")) bdsm.energy += 3;
                        let lostHp = 100 - bdsm.hp;
                        let heal = lostHp * 0.10;
                        bdsm.hp = Math.min(100, bdsm.hp + heal);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [FG TRIGGER] ${u.name} basic with FG ‚Üí BDSM +${heal.toFixed(1)}% HP (now ${bdsm.hp.toFixed(1)}%)`, "#ec4899");
                        triggerBoundlessSepal(bdsm);
                    }
                }
                if (u.name === "STV") {
                    trackStat(u, "damageDealt", 800);
                    log(`&nbsp;&nbsp;&nbsp;üåÄ [STV FERRYWOMAN] 800% ATK damage dealt`, "#a78bfa");
                    if (Math.random() < 0.80) {
                        boss.veilOfMist = true; boss.veilOfMistRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV BASIC] Boss Veil of Mist applied (2r)`, "#a78bfa");
                    }
                    units.filter(a => a.isFr).forEach(a => {
                        tryBuff(a, "dr", 0.10, 2, "STV Ferrywoman Front");
                        refreshBuff(a, "ci", 0.10, 2, "STV Ferrywoman Front");
                    });
                    units.filter(a => !a.isFr).forEach(a => tryBuff(a, "atk", 0.10, 2, "STV Ferrywoman Back"));
                    if (Math.random() < 0.80) {
                        units.filter(a => !a.isFr).forEach(a => addBuff(a, "allDmg", 0.08, 2, "STV Noble Sub (backline)"));
                        units.filter(a => a.isFr).forEach(a => addBuff(a, "allDmgReduction", 0.08, 2, "STV Noble Sub (frontline)"));
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [STV NOBLE SUB] Backline +8% allDmg, Frontline +8% allDmgReduction (80% proc)`, "#a78bfa");
                    }
                    if (u.stygianMark) triggerFF(u, u);
                }
                { let stvHero = units.find(s => s.name === "STV");
                  if (stvHero && u.name !== "STV" && u.stygianMark) triggerFF(u, stvHero); }
                if (u.name === "SQH" && !silenced) {
                    tryBuff(u, "crit", 0.18, 4, "SQH Queen's Edict");
                    tryBuff(u, "cd",   0.18, 4, "SQH Queen's Edict");
                    boss.critDebuff = (boss.critDebuff || 0) + 0.25;
                    boss.critDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üëë [SQH QUEEN'S EDICT] Boss Crit -25% for 2 rounds (total: -${(boss.critDebuff*100).toFixed(0)}%)`, "#f59e0b");
                }
                if (u.name === "LBRM" && !silenced) {
                    if (u.powerOfDream >= 2) {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream ‚â•2 ‚Üí Dreamland Dominion fires as basic! (+6 trans)`, "#f0abfc");
                        // Apply imprint basic effects as if this were a basic action
                        if (imp === "foresight") {
                            if (u.cc.seal <= 0 && checkC(u, "Foresight Energy +50")) { u.energy += 50; }
                            addBuff(u, "allDmg", 0.30, 15, "Foresight allDmg (basic)");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM PoD] Foresight basic: +50 energy, +30% allDmg`, "#f0abfc");
                        }
                        if (imp === "destiny") {
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM PoD] Destiny basic: triggering for all allies`, "#f0abfc");
                            units.forEach(a => {
                                if (Math.random() < 0.75) { if (checkC(a, "Destiny +20", "+20")) a.energy += 20; }
                                if (Math.random() < 0.50) { if (checkC(a, "Destiny +20 bonus", "+20")) a.energy += 20; }
                            });
                        }
                        u.trans += 6;
                        let frontline2 = units.filter(a => a.isFr);
                        trackStat(u, "damageDealt", 2400);
                        let dmDur2 = 4;
                        frontline2.forEach(a => {
                            a.buffs.dr.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Frontline DR debuff" });
                            a.buffs.ci.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Frontline CI debuff" });
                        });
                        units.filter(a => !a.isFr).forEach(a => {
                            a.buffs.dr.push({ value: -0.15, rounds: dmDur2, source: "DD(BB) Backline DR debuff" });
                        });
                        let hs2 = units.reduce((a,b)=>(a.spd>b.spd?a:b));
                        let ha2 = units.find(u2=>u2.isM)||units[0];
                        let s1h2 = units.find(a=>a.lbrmSlot1)||units[0];
                        [[hs2,"Wings"],[ha2,"Magnification"],[s1h2,"Protection"]].forEach(([tgt,type])=>{
                            if(type==="Wings"&&!tgt.mirrorMagicWings){tgt.dreamMagicWings=true;refreshBuff(tgt,"ci",0.10,dmDur2,"Dream Magic Wings CI");refreshBuff(tgt,"spd",0.10,dmDur2,"Dream Magic Wings SPD");}
                            if(type==="Magnification"&&!tgt.mirrorMagicMagnification){tgt.dreamMagicMagnification=true;addBuff(tgt,"allDmg",0.12,dmDur2,"Dream Magic Magnification");}
                            if(type==="Protection"&&!tgt.mirrorMagicProtection){tgt.dreamMagicProtection=true;}
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [DD(BB)] Dream Magic ${type} ‚Üí ${tgt.name}`, "#f0abfc");
                        });
                        u.powerOfDream = 0;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM] Power of Dream consumed ‚Üí 0`, "#f0abfc");
                        usedBasic = true;
                    } else {
                        trackStat(u, "damageDealt", 1200);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM SHADOW] 1200% ATK damage`, "#f0abfc");
                        units.forEach(a => tryBuff(a, "spd", 0.20, 2, "Shadow of Blossom Realm SPD"));
                        let hspd = units.reduce((a,b)=>(a.spd>b.spd?a:b));
                        addBuff(hspd, "drOffset", 0.20, 2, "Shadow CI Offset");
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW] All +20%SPD (2r); ${hspd.name} +20% CI Offset (2r)`, "#f0abfc");
                        if (Math.random() < 0.5) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW DEEP] Boss SPD -10 for 2 rounds (tracked)`, "#f0abfc");
                        if (Math.random() < 0.5) {
                            if (checkC(hspd, "LBRM Shadow Noble", "+50")) hspd.energy += 50;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [SHADOW NOBLE] ${hspd.name} +50 energy (50% proc)`, "#f0abfc");
                        }
                    }
                }
                if (u.name === "LFA" && !silenced) {
                    trackStat(u, "damageDealt", 960);
                    log(`&nbsp;&nbsp;&nbsp;üëø [LFA DEADLY GRASP] 960% ATK damage dealt`, "#c084fc");
                    if (!sealed) {
                        boss.ciDebuff = (boss.ciDebuff || 0) + 0.18;
                        boss.ciDebuffRounds = 3;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA BASIC] Boss CI -18% for 3 rounds (total: -${(boss.ciDebuff*100).toFixed(0)}%)`, "#c084fc");
                        tryBuff(u, "crit", 0.24, 4, "LFA Deadly Grasp");
                        boss.drDebuff = (boss.drDebuff || 0) + 0.05;
                        boss.drDebuffRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA NOBLE SUB] Boss DR -5% for 2 rounds (total: -${(boss.drDebuff*100).toFixed(0)}%)`, "#c084fc");
                    }
                }
                if (u.name === "BDSM" && !silenced) {
                    trackStat(u, "damageDealt", 2000);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM RAVENOUS HUNGER] 2000% ATK damage dealt`, "#ec4899");
                    boss.drDebuff = (boss.drDebuff || 0) + 0.10;
                    boss.drDebuffRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM BASIC] Boss DR -10% for 2 rounds (total: -${(boss.drDebuff*100).toFixed(0)}%)`, "#ec4899");
                    let lostHp = 100 - u.hp;
                    u.hp = Math.min(100, u.hp + lostHp * 0.20);
                    log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM BASIC] Self +${(lostHp*0.20).toFixed(1)}% HP restored (now ${u.hp.toFixed(1)}%)`, "#ec4899");
                    triggerBoundlessSepal(u);
                    if (Math.random() < 0.5) {
                        if (checkC(u, "BDSM Noble Sub", "+20")) u.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM NOBLE SUB] +20 Energy (offsettable)`, "#ec4899");
                    }
                }

                if (u.name === "ELY" && u.cc.seal <= 0) {
                    boss.shrink = true;
                    boss.shrinkRounds = 2;
                    log(`&nbsp;&nbsp;&nbsp;üåä [ELY BASIC] Boss Shrink applied/refreshed (2r, √ó1.4 dmg)`, "#38bdf8");
                }
                if (u.name === "HW" && u.cc.seal <= 0) {
                    const prev = boss.watcherMark || 0;
                    boss.watcherMark = Math.min(3.0, prev + 0.35);
                    log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è [HW BASIC] Watcher Mark +35% ‚Üí ${(boss.watcherMark*100).toFixed(0)}% (cap 300%)`, "#38bdf8");
                }
                tryStarSoul(u);
                triggerPupil(u);
                triggerNova(u);
                if (u.name === "BDSM" && !u.infuseUsed) {
                    u.infuseUsed = true;
                    if (u.hp >= 70) {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP ‚â•70% (${u.hp.toFixed(1)}%): -60% HP, granting Shield+CI to self & backline`, "#ec4899");
                        u.hp = Math.max(0, u.hp - 60);
                        units.filter(a => !a.isFr || a === u).forEach(a => {
                            a.shield = Math.min(100, (a.shield || 0) + 40);
                            refreshBuff(a, "ci", 0.15, 2, "BDSM Infuse with Flavor");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [INFUSE] ${a.name} Shield +40% MaxHP, CI +15% (2r)`, "#ec4899");
                        });
                        triggerBoundlessSepal(u);
                    } else {
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [INFUSE WITH FLAVOR] HP <70% (${u.hp.toFixed(1)}%): restoring 15% HP + Shield`, "#ec4899");
                        u.hp = Math.min(100, u.hp + 15);
                        u.shield = Math.min(100, (u.shield || 0) + 15);
                        triggerBoundlessSepal(u);
                    }
                }

            } else {
                u.turnsLost++;
                log(`üö´ ACTION: SKIPPED (${u.cc.fear > 0 ? "Fear" : u.cc.silence > 0 ? "Silence+NoEnergy" : "Unknown"})`, "#ef4444");
            }

            // 12-stack transitions
            if (u.trans >= 12) {
                u.trans -= 12;
                log(`&nbsp;&nbsp;&nbsp;üíé 12-Stack Transition`);
                units.forEach(a => {
                    if (u.name === "SQH") {
                        // Moon Abyss + Comet Hop: all heroes including self
                        tryBuff(a, "atk",    0.10, 2, "SQH Transition (Moon Abyss)");
                        addBuff(a, "allDmg", 0.10, 2, "SQH Transition (Moon Abyss)");
                        addBuff(a, "allDmgReduction", 0.20, 2, "SQH Transition (Moon Abyss)");
                        trackStat(a, "healingDone", 50);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH MOON ABYSS] ${a.name} +50% Max HP healed`, "#f59e0b");
                        tryBuff(a, "dr", 0.20, 2, "SQH Comet Hop");
                    }
                    if (u.name === "SQH") {
                        // Glowed Glory: +20 energy to ALL allies including self
                        if (checkC(a, "SQH Glowed Glory", "+20")) a.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH GLOWED GLORY] ${a.name} +20 Energy (offsettable)`, "#f59e0b");
                        // Sun Halo + Acheron Barque: self only
                        if (a === u) {
                            addBuff(u, "allDmg", 0.15, 2, "SQH Sun Halo");
                            boss.spdDebuff = (boss.spdDebuff || 0) + 20;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëë [SQH ACHERON BARQUE] Boss SPD -20 (total: -${boss.spdDebuff})`, "#f59e0b");
                        }
                    }
                    if (u.name === "BDSM") {
                        if (a.franticGluttony) {
                            addBuff(a, "atk", 0.25, 3, "BDSM Moon Abyss");
                            tryBuff(a, "cd",  0.25, 3, "BDSM Moon Abyss");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM MOON ABYSS] ${a.name} (FG) +25% ATK, +25% CD (3r, direct)`, "#ec4899");
                        }
                        if (checkC(a, "BDSM Glowed Glory", "+20")) a.energy += 20;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM GLOWED GLORY] ${a.name} +20 Energy (offsettable)`, "#ec4899");
                        if (a.isM) { addBuff(a, "allDmg", 0.15, 2, "BDSM Acheron Barque"); }
                        if (a === units[0]) {
                            boss.allDmgDealtDebuff = (boss.allDmgDealtDebuff || 0) + 0.10;
                            boss.allDmgDealtDebuffRounds = 2;
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BDSM COMET HOP] Boss All-Damage Dealt -10% for 2 rounds`, "#ec4899");
                        }
                        if (!a.isFr) { addBuff(a, "allDmg", 0.10, 2, "BDSM Sun Halo"); }
                    }
                    if (u.name === "LBRM") {
                        trackStat(u, "damageDealt", 3000);
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANSITION] 30% Max HP dmg to frontline (capped 3000%)`, "#f0abfc");
                        let transEffect = Math.floor(Math.random() * 3);
                        if (transEffect === 0) {
                            units.filter(a => a.dreamMagicWings || a.mirrorMagicWings).forEach(a => {
                                tryBuff(a, "atk", 0.20, 2, "LBRM Trans Wings ATK");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 1] ${a.name} (Wings) +20% ATK 2r`, "#f0abfc");
                            });
                        } else if (transEffect === 1) {
                            units.filter(a => a.dreamMagicMagnification || a.mirrorMagicMagnification).forEach(a => {
                                addBuff(a, "allDmgReduction", 0.10, 2, "LBRM Trans Magnification DR");
                                a.hp = Math.min(100, a.hp + 33);
                                trackStat(a, "healingDone", 33);
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 2] ${a.name} (Magnification) +10% allDmgReduction 2r, +33% HP`, "#f0abfc");
                            });
                        } else {
                            units.filter(a => a.dreamMagicProtection || a.mirrorMagicProtection).forEach(a => {
                                a.beeSugarCoat = true;
                                refreshBuff(a, "ci", 0.50, 999, "Bee Sugar-coat CI");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [LBRM TRANS 3] ${a.name} (Protection) Bee Sugar-coat +50% CI 4r`, "#f0abfc");
                            });
                        }
                        units.forEach(a => tryBuff(a, "armor", 0.35, 2, "LBRM Glowed Glory"));
                        let lbrmMaxAtk = units.find(a => a.isM) || units[0];
                        tryBuff(lbrmMaxAtk, "allDmg", 0.15, 2, "LBRM Acheron Barque");
                        units.filter(a => !a.isFr).forEach(a => { addBuff(a, "allDmg", 0.10, 3, "LBRM Sun Halo"); });
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.10; boss.atkDebuffRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;üå∏ [LBRM PIVOTS] Glowed Glory armor+35% | Acheron Barque ${lbrmMaxAtk.name} +15%allDmg 2r | Comet Hop boss ATK-10% | Sun Halo backline +10%allDmg 3r`, "#f0abfc");
                    }
                    if (u.name === "LFA") {
                        trackStat(u, "damageDealt", 3000);
                        log(`&nbsp;&nbsp;&nbsp;üëø [LFA MOON ABYSS] 1500% ATK √ó 2 = 3000% ATK damage`, "#c084fc");
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.50; boss.atkDebuffRounds = 3;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA MOON ABYSS] Boss ATK -50% for 3 rounds`, "#c084fc");
                        trackStat(u, "damageDealt", 1000);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA GLOWED GLORY] +1000% ATK damage`, "#c084fc");
                        boss.atkDebuff = (boss.atkDebuff || 0) + 0.15; boss.atkDebuffRounds = Math.max(boss.atkDebuffRounds || 0, 2);
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëø [LFA ACHERON BARQUE] Boss ATK -15% (2r)`, "#c084fc");
                        refreshBuff(u, "ci", 0.20, 2, "LFA Comet Hop");
                        addBuff(u, "allDmg", 0.15, 2, "LFA Sun Halo");
                    }
                });
            }

            // DGN basic
            if (usedBasic && u.name === "DGN") fireDGNBasic(u, r);
            // Foresight / Destiny imprint
            if (imp === "foresight") {
                if (usedBasic) {
                    if (u.cc.seal <= 0 && checkC(u, "Foresight Energy +50")) { u.energy += 50; }
                    addBuff(u, "allDmg", 0.30, 15, "Foresight allDmg (basic)");
                }
                if (usedActive) {
                    tryBuff(u, "crit", 0.50, 2, "Foresight Crit (active)");
                    tryBuff(u, "cd", 1.00, 2, "Foresight CD (active)");
                }
            }
            if (usedBasic && imp === "destiny") {
                log(`&nbsp;&nbsp;&nbsp;‚ö° [DESTINY] Triggering for all allies`, "#38bdf8");
                units.forEach(a => {
                    if (Math.random() < 0.75) { if (checkC(a,"Destiny +20","+20")) a.energy += 20; }
                    if (Math.random() < 0.50) { if (checkC(a,"Destiny +20 bonus","+20")) a.energy += 20; }
                });
            }

            // BOSS COUNTERATTACK
            // Pet gains 10 energy per boss hit (cannot be sealed/blocked)
                pet.energy += 10;
                log(`&nbsp;&nbsp;&nbsp;üêæ [PET] ${u.name} hit boss ‚Üí Pet +10 energy (now ${pet.energy})`, "#a78bfa");
                if (didHitBoss) {
                log(`&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [BOSS COUNTER] Corrupting Touch triggered!`, "#ef4444");
                units.forEach(h => {
                    h.calamity++;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ‚Üí ${h.name} +1 Calamity (now ${h.calamity})`, "#ef4444");
                    trigCal(h);
                    if (Math.random() < 0.5) { h.curse++; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ‚Üí ${h.name} +1 Curse (50%) (now ${h.curse})`, "#ef4444"); }
                });
            }
        }); // end ord.forEach

        log(`&nbsp;&nbsp;&nbsp;üî• END-OF-TURN CALAMITY CHECK`, "#ef4444");
        units.forEach(u => {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Üí ${u.name} Calamity: ${u.calamity}`, "#ef4444");
            trigCal(u);
        });

        let pupilUnits = units.filter(u => u.hasPupil);

        log(`&nbsp;&nbsp;&nbsp;‚òÑÔ∏è BOSS ACTIVE: CATASTROPHIC ROAR (3000% ATK √ó 3, +2 Cal & Curse, dodge applies)`, "#ef4444");
        boss.atkSteal = (boss.atkSteal || 0) + 0.08;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [CATASTROPHIC ROAR] Boss steals 8% ATK (3r), enemy Armor -100%`, "#ef4444");
         // DGN Double Nature counter triggers on boss active
         { const dgn = units.find(u => u.name === "DGN" && u.cc.seal <= 0); if (dgn) triggerDGNDoubleNature(dgn, r); }
        units.forEach(u => {
            let effectiveDodge = (u.pupilDodgeRounds > 0) ? 1.0 : u.dodge;
            if (u.pupilDodgeRounds > 0) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ${u.name} has Pupil 100% dodge active (${u.pupilDodgeRounds} rounds left)`, "#e879f9");
            }
            let dodged = Math.random() < effectiveDodge;
            if (dodged) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üí® ${u.name} DODGED the boss active! (no Calamity/Curse)`, "#a3e635");
                pupilUnits.forEach(pw => {
                    if (checkC(pw, "Pupil Dodge Energy", "+10")) pw.energy += 10;
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è [PUPIL] ${pw.name} +10 Energy (ally ${u.name} dodged)`, "#e879f9");
                });
            } else {
                u.calamity += 2;
                u.curse += 2;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Üí ${u.name} +2 Calamity (now ${u.calamity}) & +2 Curse (now ${u.curse})`, "#ef4444");
                trigCal(u);

                let lbrm2 = units.find(x => x.name === "LBRM" && x.cc.seal <= 0);
                if (lbrm2 && lbrm2.energy >= 30) {
                    lbrm2.energy -= 30;
                    lbrm2.powerOfDream = Math.min(3, lbrm2.powerOfDream + 1);
                    let ccKeys2 = ["silence","fear","seal"].filter(k => u.cc[k] > 0);
                    if (ccKeys2.length > 0) { let rem2 = ccKeys2[Math.floor(Math.random()*ccKeys2.length)]; u.cc[rem2]=0; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON] ${u.name} ${rem2} removed, LBRM PoD=${lbrm2.powerOfDream}`, "#f0abfc"); }
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [BRILLIANT BOON DEEP] ${u.name} Shield 3500% ATK granted`, "#f0abfc");
                }
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ö° ${u.name} hit by boss active: +10 Energy`, "#38bdf8");
                if (checkC(u, "Boss Active Hit Energy", "+10")) u.energy += 10;

                let specterWearer = units.find(s => s.hasS);
                if (specterWearer && specterWearer.cc.seal <= 0) {
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîÆ ${u.name} Specter bonus: +10 Energy (boss hit)`, "#f472b6");
                    if (checkC(u, "Boss Active Hit Specter Bonus", "+10")) u.energy += 10;
                }

                if (u.name === "LBRM" && !u.mirrorMagicWingsUsed) {
                    u.mirrorMagicWingsUsed = true;
                    let ccK = ["silence","fear","seal"].filter(k => u.cc[k] > 0);
                    if (ccK.length > 0) {
                        let rk = ccK[Math.floor(Math.random()*ccK.length)];
                        u.cc[rk] = 0;
                        if (checkC(u, "LBRM Mirror Wings", "+30")) u.energy += 30;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üå∏ [MIRROR WINGS] ${u.name} CC removed (${rk}), +30 energy`, "#f0abfc");
                    }
                }
                if (u.name === "STV") {
                    log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE] STV hit by boss active`, "#a78bfa");
                    if (Math.random() < 0.80) {
                        boss.veilOfMist = true; boss.veilOfMistRounds = 2;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE] Boss: Veil of Mist applied (2r)`, "#a78bfa");
                        if (Math.random() < 0.70) {
                            applyLI("Fatal Allure (boss had VoM)");
                            if (Math.random() < 0.60) {
                                trackStat(u, "damageDealt", 800);
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE DEEP SUB] 800% ATK damage + boss -50 energy`, "#a78bfa");
                            }
                            let noSM = units.filter(a => !a.stygianMark);
                            if (noSM.length > 0) {
                                let pick = noSM[Math.floor(Math.random() * noSM.length)];
                                pick.stygianMark = true;
                                pick.stygianMarkStack = Math.min(2, (pick.stygianMarkStack || 0) + 1);
                                addBuff(pick, "allDmg", pick.stygianMarkStack * 0.10, 2, "Stygian Mark (Fatal Allure Noble)");
                                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåÄ [FATAL ALLURE NOBLE SUB] ${pick.name} gains Stygian Mark (2r)`, "#a78bfa");
                            }
                        }
                    }
                }
            }
            for (let k in u.cc) if (u.cc[k] > 0) u.cc[k]--;
        });

        log(`&nbsp;&nbsp;&nbsp;üõ°Ô∏è END-OF-ROUND CC CLEANSE`, "#a78bfa");
        const ccTypes = ["silence","fear","seal"];
        units.forEach(u => {
            let activeCC = ccTypes.filter(t => u.cc[t] > 0);
            if (activeCC.length > 0) {
                // First cleanse (always)
                let pick = activeCC[Math.floor(Math.random() * activeCC.length)];
                u.cc[pick] = 0;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è ${u.name} removes ${pick.toUpperCase()}`, "#a78bfa");
                // Upgraded Control Purify: 50% chance to cleanse one more
                if (u.upgradedPurify) {
                    activeCC = ccTypes.filter(t => u.cc[t] > 0);
                    if (activeCC.length > 0 && Math.random() < 0.5) {
                        let pick2 = activeCC[Math.floor(Math.random() * activeCC.length)];
                        u.cc[pick2] = 0;
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ú¶ ${u.name} UPGRADED PURIFY removes ${pick2.toUpperCase()}`, "#a78bfa");
                    }
                }
            } else {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üõ°Ô∏è ${u.name} has no CC to remove`, "#a78bfa");
            }
        });

        log(`&nbsp;&nbsp;&nbsp;ü™û ARTIFACT END-OF-ROUND PHASE`, "#38bdf8");

        boss.spiritMirrorRound++;
        let smWearers = units.filter(u => u.art === "Spiritual Mirror" && u.cc.seal <= 0);
        if (smWearers.length > 0 && (boss.spiritMirrorRound === 1 || boss.spiritMirrorRound % 3 === 0)) {
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SPIRITUAL MIRROR] Every-3-round pulse (round ${boss.spiritMirrorRound})`, "#38bdf8");
            units.forEach(a => {
                let hasSM = a.art === "Spiritual Mirror";
                let mult = hasSM ? 2 : 1;
                addBuff(a, "allDmg", 0.045 * mult, 3, `Spiritual Mirror allDmg (√ó${mult})`);
                addBuff(a, "dr", 0.03 * mult, 3, `Spiritual Mirror DR (√ó${mult})`);
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SM] ${a.name}: +${(4.5*mult).toFixed(1)}% allDmg, +${(3*mult).toFixed(0)}% DR (3r decay)`, "#38bdf8");
            });
            boss.ciDebuff = (boss.ciDebuff || 0) + 0.03;
            boss.ciDebuffRounds = 3;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SM] Boss CI -3% (3r decay)`, "#38bdf8");
        }

        units.forEach(u => {
            if (u.cc.seal > 0) return;
            if (u.art === "Spiritual Mirror") {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü™û [SPIRITUAL MIRROR] EoR: +15 energy & +6% HP to all allies`, "#38bdf8");
                units.forEach(a => {
                    if (checkC(a, "Spiritual Mirror Energy", "+15")) a.energy += 15;
                    a.hp = Math.min(100, a.hp + 6);
                    trackStat(a, "healingDone", 6);
                });
            }

            // ‚îÄ‚îÄ SCISSORS: replicate boss ATK & HD to self + same-line allies only ‚îÄ‚îÄ
            if (u.art === "Scissors") {
                let totalBossATK = (boss.atkBuff || 0) + (boss.atkSteal || 0);
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è [SCISSORS] Boss total ATK: +${(totalBossATK*100).toFixed(0)}% (atkBuff ${((boss.atkBuff||0)*100).toFixed(0)}% + atkSteal ${((boss.atkSteal||0)*100).toFixed(0)}%) ‚Üí 30% replicated to self + same-line allies`, "#38bdf8");
                // Only buff self + allies on the same line (frontline or backline)
                let scissorsTargets = units.filter(a => a.isFr === u.isFr);
                scissorsTargets.forEach(a => {
                    if (totalBossATK > 0) {
                        let replicatedATK = totalBossATK * 0.30;
                        if (checkC(a, "Scissors ATK repl.")) {
                            addBuff(a, "atk", replicatedATK, 15, "Scissors (boss ATK repl.)");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è ${a.name}: +${(replicatedATK*100).toFixed(1)}% ATK (30% of +${(totalBossATK*100).toFixed(0)}%)`, "#38bdf8");
                        }
                    }
                    if (bossHDStacks > 0) {
                        let replicatedHD = bossHDStacks * 0.125 * 0.30;
                        if (checkC(a, "Scissors HD repl.")) {
                            addBuff(a, "hd", replicatedHD, 15, "Scissors (boss HD repl.)");
                            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚úÇÔ∏è ${a.name}: +${(replicatedHD*100).toFixed(1)}% HD (30% of boss ${(bossHDStacks*12.5).toFixed(1)}% HD)`, "#38bdf8");
                        }
                    }
                });
            }

            if (u.art === "Jade Toad") triggerJadeToad(u);

            if (u.art === "Antlers") {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü¶å [ANTLERS] ${u.name}: +9% allDmg (permanent), +1% DR (2r, offsettable)`, "#38bdf8");
                addBuff(u, "allDmg", 0.09, 999, "Antlers Power of Wildness allDmg");
                tryBuff(u, "dr", 0.01, 10, "Antlers Power of Wildness DR");
            }
            // ‚îÄ‚îÄ Specter EoR Pulse (rounds 1-5): fires during the specter holder's artifact turn ‚îÄ‚îÄ
            if (r <= 5 && u.hasS && u.cc.seal <= 0) {
                log(`&nbsp;&nbsp;&nbsp;üîÆ [SPECTER EoR PULSE R${r}/5] ${u.name}`, "#f472b6");
                if (checkC(u, "Specter EoR Self", "+50")) u.energy += 50;
                let specAllies = units.filter(a => a !== u);
                let randSA = specAllies[Math.floor(Math.random() * specAllies.length)];
                if (checkC(randSA, "Specter EoR Ally", "+50")) randSA.energy += 50;
            }
            // ‚îÄ‚îÄ Global Surge: each hero gets +50 energy after their own EoR actions ‚îÄ‚îÄ
            if (checkC(u, "Global Surge", "+50")) u.energy += 50;
        });

        log(`&nbsp;&nbsp;&nbsp;‚ò†Ô∏è ABYSSAL INVASION (boss end-of-round)`, "#ef4444");
        let invasionTarget = units.find(u => u.isM);
        if (invasionTarget) {
            invasionTarget.energy = Math.max(0, invasionTarget.energy - 100);
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} -100 Energy (now ${invasionTarget.energy})`, "#ef4444");
            invasionTarget.curse += 3;
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} +3 Curse of Decay (now ${invasionTarget.curse})`, "#ef4444");
            invasionTarget.buffs.atk.push({ value: -0.40, rounds: 2, source: "Abyssal Invasion ATK debuff" });
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${invasionTarget.name} ATK -40% for 2 rounds`, "#ef4444");
        }
        boss.atkBuff = (boss.atkBuff || 0) + 0.06;
        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] Boss self +6% ATK (total: +${((boss.atkBuff||0)*100).toFixed(0)}%)`, "#ef4444");
        units.forEach(u => {
            if (u.calamity > 0) {
                if (Math.random() < 0.25) {
                    let buffTypes = Object.keys(u.buffs).filter(t => u.buffs[t].filter(b => b.value > 0).length > 0);
                    if (buffTypes.length > 0) {
                        let pick = buffTypes[Math.floor(Math.random() * buffTypes.length)];
                        let idx = u.buffs[pick].findIndex(b => b.value > 0);
                        let removed = u.buffs[pick].splice(idx, 1)[0];
                        log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${u.name} (25% proc): ${pick.toUpperCase()} +${(removed.value*100).toFixed(1)}% buff removed`, "#ef4444");
                    }
                }
            } else {
                u.calamity++;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ò†Ô∏è [INVASION] ${u.name} (no Calamity): +1 Calamity`, "#ef4444");
                trigCal(u);
            }
        });

        // Specter EoR pulse is now inline in the artifact loop below

        log(`&nbsp;&nbsp;&nbsp;‚ùÑÔ∏è CALAMITY PURGE (-1 per hero)`, "#a5b4fc");
        units.forEach(u => {
            if (u.calamity > 0) { u.calamity--; log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚ùÑÔ∏è ${u.name}: -1 Cal (now ${u.calamity})`, "#a5b4fc"); }
        });

        // Pet end-of-round +20 energy
        pet.energy += 20;
        log(`&nbsp;&nbsp;&nbsp;üêæ [PET EoR] +20 energy ‚Üí ${pet.energy} total`, "#a78bfa");

        log(`&nbsp;&nbsp;&nbsp;‚è±Ô∏è BUFF TICK (end of round)`, "#34d399");
        units.forEach(u => {
            // Sample DR and ADR rounds 6-15 only (avoids Island 9 decay skew)
            if (r >= 6) {
                let snapDR  = getBuffTotal(u, "dr");
                let snapADR = getBuffTotal(u, "allDmgReduction");
                u.minDR  = Math.min(u.minDR,  snapDR);  u.maxDR  = Math.max(u.maxDR,  snapDR);
                u.minADR = Math.min(u.minADR, snapADR); u.maxADR = Math.max(u.maxADR, snapADR);
                u.drTotal += snapDR; u.drSamples++;
                u.adrTotal += snapADR; u.adrSamples++;
            }
            tickBuffs(u);
            if (u.stygianMark) { u.stygianMark = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [SM] ${u.name} Stygian Mark expired`, "#64748b"); }
            if (u.veilOfMist) { u.veilOfMistRounds--; if (u.veilOfMistRounds <= 0) { u.veilOfMist = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [VoM] ${u.name} Veil of Mist expired`, "#64748b"); } }
            if (u.fearAbyssalGaze) { u.fearAbyssalGazeRounds--; if (u.fearAbyssalGazeRounds <= 0) { u.fearAbyssalGaze = false; log(`&nbsp;&nbsp;&nbsp;üëπ [FAG] ${u.name} Fear-Abyssal Gaze expired`, "#64748b"); } }
            if (u.lethalIncense) { u.lethalIncenseRounds--; if (u.lethalIncenseRounds <= 0) { u.lethalIncense = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [LI] ${u.name} Lethal Incense expired ‚Äî ally takes 30% Max HP damage`, "#a78bfa"); let stvH = units.find(s => s.name === "STV"); if (stvH) trackStat(stvH, "damageDealt", 1500); } }
        });
        if (boss.lethalIncense) {
            boss.lethalIncenseRounds--;
            if (boss.lethalIncenseRounds <= 0) { let stvH = units.find(s => s.name === "STV"); expireLI(stvH); }
        }
        if (boss.veilOfMist) { boss.veilOfMistRounds--; if (boss.veilOfMistRounds <= 0) { boss.veilOfMist = false; log(`&nbsp;&nbsp;&nbsp;üåÄ [VoM] Boss Veil of Mist expired`, "#64748b"); } }
        if (boss.healReductionRounds > 0) { boss.healReductionRounds--; if (boss.healReductionRounds <= 0) { boss.healReduction = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV COMET HOP] Boss heal reduction expired`, "#64748b"); } }
        if (boss.shrinkRounds > 0) { boss.shrinkRounds--; if (boss.shrinkRounds <= 0) { boss.shrink = false; log(`&nbsp;&nbsp;&nbsp;üåä [SHRINK] Boss shrink expired`, "#38bdf8"); } }
        if (r > 2 && !boss.shrink) shrinkMissedRound = true;

        // ‚îÄ‚îÄ Boss removes 3 random debuffs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        {
            const activeDebuffs = [];
            if ((boss.atkDebuff || 0) > 0 || (boss.atkSteal || 0) > 0) activeDebuffs.push("atk");
            if ((boss.armorDebuff || 0) > 0) activeDebuffs.push("armor");
            if ((boss.drDebuff || 0) > 0) activeDebuffs.push("dr");
            if ((boss.ciDebuff || 0) > 0) activeDebuffs.push("ci");
            if ((boss.spdDebuff || 0) > 0) activeDebuffs.push("spd");
            if ((boss.critDebuff || 0) > 0) activeDebuffs.push("crit");
            if ((boss.healReduction || 0) > 0) activeDebuffs.push("heal");
            if (boss.bleed && boss.bleed.length > 0) activeDebuffs.push("bleed");
            if ((boss.burn || 0) > 0) activeDebuffs.push("burn");
            if ((boss.watcherMark || 0) > 0) activeDebuffs.push("watcherMark");

            // Shuffle and pick up to 3
            for (let i = activeDebuffs.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [activeDebuffs[i], activeDebuffs[j]] = [activeDebuffs[j], activeDebuffs[i]];
            }
            const toRemove = activeDebuffs.slice(0, 3);
            if (toRemove.length > 0) {
                log(`&nbsp;&nbsp;&nbsp;üíÄ [BOSS CLEANSE] Removes ${toRemove.length} debuff(s): ${toRemove.join(", ")}`, "#ef4444");
                toRemove.forEach(d => {
                    if (d === "atk")        { boss.atkDebuff = 0; boss.atkSteal = 0; boss.atkDebuffRounds = 0; }
                    if (d === "armor")      { boss.armorDebuff = 0; boss.armorDebuffRounds = 0; }
                    if (d === "dr")         { boss.drDebuff = 0; boss.drDebuffRounds = 0; }
                    if (d === "ci")         { boss.ciDebuff = 0; boss.ciDebuffRounds = 0; }
                    if (d === "spd")        { boss.spdDebuff = 0; boss.spdDebuffRounds = 0; }
                    if (d === "crit")       { boss.critDebuff = 0; boss.critDebuffRounds = 0; }
                    if (d === "heal")       { boss.healReduction = 0; boss.healReductionRounds = 0; }
                    if (d === "bleed")      { boss.bleed = []; }
                    if (d === "burn")       { boss.burn = 0; }
                    if (d === "watcherMark"){ boss.watcherMark = 0; }
                });
            }
        }

        if (boss.bleed && boss.bleed.length > 0) {
            log(`&nbsp;&nbsp;&nbsp;ü©∏ BLEED PHASE`, "#f59e0b");
            let totalBleedDmg = 0;
            boss.bleed = boss.bleed.map(b => {
                totalBleedDmg += b.dmg;
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü©∏ Bleed tick: ${b.dmg}% ATK (${b.rounds - 1} rounds remaining)`, "#f59e0b");
                return { ...b, rounds: b.rounds - 1 };
            }).filter(b => b.rounds > 0);
            let sqh = units.find(u => u.name === "SQH");
            if (sqh) trackStat(sqh, "damageDealt", totalBleedDmg);
            log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ü©∏ Total Bleed damage this round: ${totalBleedDmg}% ATK`, "#f59e0b");
        }

        if (boss.critDebuffRounds > 0) { boss.critDebuffRounds--; if (boss.critDebuffRounds <= 0) { boss.critDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üëë [SQH] Boss Crit debuff expired`, "#64748b"); } }
        if (boss.drDebuffRounds > 0) { boss.drDebuffRounds--; if (boss.drDebuffRounds <= 0) { boss.drDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss DR debuff expired`, "#64748b"); } }
        if (boss.ciDebuffRounds > 0) { boss.ciDebuffRounds--; if (boss.ciDebuffRounds <= 0) { boss.ciDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss CI debuff expired`, "#64748b"); } }
        if (boss.allDmgReductionDebuffRounds > 0) { boss.allDmgReductionDebuffRounds--; if (boss.allDmgReductionDebuffRounds <= 0) { boss.allDmgReductionDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss AllDmgReduction debuff expired`, "#64748b"); } }
        if (boss.allDmgDealtDebuffRounds > 0) { boss.allDmgDealtDebuffRounds--; if (boss.allDmgDealtDebuffRounds <= 0) { boss.allDmgDealtDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üå∏ [BDSM] Boss AllDmgDealt debuff expired`, "#64748b"); } }
        if (boss.atkSteal > 0) { log(`&nbsp;&nbsp;&nbsp;üëø [LFA DKM] Boss ATK stolen this fight: -${(boss.atkSteal*100).toFixed(0)}% ATK (permanent)`, "#c084fc"); }
        if (boss.atkDebuffRounds > 0) { boss.atkDebuffRounds--; if (boss.atkDebuffRounds <= 0) { boss.atkDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss ATK debuff expired`, "#64748b"); } }
        if (boss.armorDebuffRounds > 0) { boss.armorDebuffRounds--; if (boss.armorDebuffRounds <= 0) { boss.armorDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss Armor debuff expired`, "#64748b"); } }
        if (boss.spdDebuffRounds > 0) { boss.spdDebuffRounds--; if (boss.spdDebuffRounds <= 0) { boss.spdDebuff = 0; log(`&nbsp;&nbsp;&nbsp;üåÄ [STV] Boss SPD debuff expired`, "#64748b"); } }

        units.forEach(u => {
            if (u.name === "SQH") {
                let aliveAllies = units.length;
                let healing = aliveAllies * 8;
                trackStat(u, "healingDone", healing);
                log(`&nbsp;&nbsp;&nbsp;üëë [SQH ULTIMATE QUEENSHIP] ${aliveAllies} allies ‚Üí +${healing}% Max HP restored`, "#f59e0b");
            }
        });

        log(`&nbsp;&nbsp;&nbsp;üëÅÔ∏è PUPIL DODGE RESET (Max ATK hero dodge resets to base)`, "#e879f9");
        units.forEach(u => {
            if (u.dodge !== u.baseDodge) {
                log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üëÅÔ∏è ${u.name} Dodge reset: ${Math.round(u.dodge*100)}% ‚Üí ${Math.round(u.baseDodge*100)}%`, "#e879f9");
                u.dodge = u.baseDodge;
            }
        });
    }

    return { units, hd: bossHDStacks, boss, shrinkMissed: shrinkMissedRound };
}

function sim(multi) {
    const out = document.getElementById('output'); out.innerHTML = ""; silent = multi;
    if (!multi) {
        runOne();
    } else {
        const N = 1000;
        let stats = {}, totalHD = 0, minHD = Infinity, maxHD = -Infinity;
        let totalWM = 0, minWM = Infinity, maxWM = -Infinity;
        let totalAS = 0, minAS = Infinity, maxAS = -Infinity;
        for (let i = 0; i < N; i++) {
            let res = runOne();
            totalHD += res.hd;
            minHD = Math.min(minHD, res.hd);
            maxHD = Math.max(maxHD, res.hd);
            const wm = (res.boss.watcherMark || 0) * 100; // as %
            totalWM += wm; minWM = Math.min(minWM, wm); maxWM = Math.max(maxWM, wm);
            const as_ = res.boss.abyssalCorruption || 0;
            totalAS += as_; minAS = Math.min(minAS, as_); maxAS = Math.max(maxAS, as_);
            res.units.forEach(u => {
                if (!stats[u.name]) stats[u.name] = {
                    acts:0, lost:0,
                    finalATK:0, minATK:Infinity, maxATK:-Infinity,
                    finalAllDmg:0, minAllDmg:Infinity, maxAllDmg:-Infinity,
                    finalHD:0, minHD:Infinity, maxHD:-Infinity,
                    peakCI:0, minPeakCI:Infinity, maxPeakCI:-Infinity,
                    avgCI:0,
                    minDR:Infinity, maxDR:-Infinity, avgDR:0,
                    minADR:Infinity, maxADR:-Infinity, avgADR:0,
                    totalEstDmg:0, minEstDmg:Infinity, maxEstDmg:-Infinity,
                    dmgPerRound: new Array(15).fill(0),
                    srcHits:0, srcDKM:0, srcLethal:0, srcBS:0, srcAddl:0, srcMain:0, srcUndying:0,
                    baseCI: u.baseCI
                };
                let s = stats[u.name];
                let atkExtra = (u.name === "LFA" && res.boss) ? (res.boss.atkSteal || 0) : 0;
                let atk = getBuffTotal(u, "atk") + atkExtra;
                let ad  = getBuffTotal(u, "allDmg");
                let hd  = getBuffTotal(u, "hd");
                s.acts += u.acts; s.lost += u.turnsLost;
                s.finalATK += atk; s.minATK = Math.min(s.minATK, atk); s.maxATK = Math.max(s.maxATK, atk);
                s.finalAllDmg += ad; s.minAllDmg = Math.min(s.minAllDmg, ad); s.maxAllDmg = Math.max(s.maxAllDmg, ad);
                s.finalHD += hd; s.minHD = Math.min(s.minHD, hd); s.maxHD = Math.max(s.maxHD, hd);
                s.peakCI += u.peakCI; s.minPeakCI = Math.min(s.minPeakCI, u.peakCI); s.maxPeakCI = Math.max(s.maxPeakCI, u.peakCI);
                s.avgCI += u.ciSamples > 0 ? (u.ciTotal / u.ciSamples) : u.baseCI;
                let snapDR  = u.drSamples  > 0 ? u.drTotal  / u.drSamples  : 0;
                let snapADR = u.adrSamples > 0 ? u.adrTotal / u.adrSamples : 0;
                if (u.totalEstDmg > 0) {
                    s.totalEstDmg += u.totalEstDmg;
                    s.minEstDmg = Math.min(s.minEstDmg, u.totalEstDmg);
                    s.maxEstDmg = Math.max(s.maxEstDmg, u.totalEstDmg);
                    if (u.dmgPerRound) u.dmgPerRound.forEach((d,i) => { s.dmgPerRound[i] = (s.dmgPerRound[i]||0) + d; });
                    s.srcHits   += (u.srcHits   || 0);
                    s.srcDKM    += (u.srcDKM    || 0);
                    s.srcLethal += (u.srcLethal || 0);
                    s.srcBS     += (u.srcBS     || 0);
                    s.srcAddl   += (u.srcAddl   || 0);
                    s.srcMain   += (u.srcMain   || 0);
                    s.srcUndying+= (u.srcUndying|| 0);
                }
                s.minDR  = Math.min(s.minDR,  u.minDR  === Infinity  ? 0 : u.minDR);  s.maxDR  = Math.max(s.maxDR,  u.maxDR  === -Infinity ? 0 : u.maxDR);  s.avgDR  += u.drSamples  > 0 ? u.drTotal  / u.drSamples  : 0;
                s.minADR = Math.min(s.minADR, u.minADR === Infinity  ? 0 : u.minADR); s.maxADR = Math.max(s.maxADR, u.maxADR === -Infinity ? 0 : u.maxADR); s.avgADR += u.adrSamples > 0 ? u.adrTotal / u.adrSamples : 0;
            });
        }
        function pct(v) { return `${(v*100).toFixed(1)}%`; }
        function dmgRange(avg, mn, mx) {
            const fmt = v => Math.round(v).toLocaleString();
            return `<span style="color:var(--accent)">${fmt(avg)}</span> <small style="color:#64748b">[${fmt(mn)} ‚Äì ${fmt(mx)}]</small>`;
        }
        function range(avg, mn, mx) {
            return `<span style="color:var(--accent)">${pct(avg)}</span> <small style="color:#64748b">[${pct(mn)} ‚Äì ${pct(mx)}]</small>`;
        }
        const fmtR = (avg, mn, mx, dec=1) => `<span style="color:var(--accent);font-weight:bold">${avg.toFixed(dec)}</span> <small style="color:#64748b">[${mn.toFixed(dec)}&ndash;${mx.toFixed(dec)}]</small>`;
        let html = `<div style="margin-bottom:14px;padding:12px 16px;background:var(--card);border:1px solid #334155;border-radius:8px;font-size:13px;display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <div>üëÅÔ∏è <strong>Watcher Mark (end of fight)</strong><br>Avg: ${fmtR(totalWM/N, minWM, maxWM)}%</div>
            <div>üëë <strong>Abyssal Corruption stacks (end of fight)</strong><br>Avg: ${fmtR(totalAS/N, minAS, maxAS)}</div>
        </div>`;
        html += `<h3>AVERAGES + RANGES (${N} FIGHTS)</h3>`;
        html += `<p><b>Boss Holy Damage Stacks:</b> avg <span style="color:var(--accent)">${(totalHD/N).toFixed(2)}</span> stacks (+${(totalHD/N*12.5).toFixed(1)}% HD) &nbsp;|&nbsp; range <small style="color:#64748b">[${minHD} ‚Äì ${maxHD} stacks / +${(minHD*12.5).toFixed(1)}% ‚Äì +${(maxHD*12.5).toFixed(1)}% HD]</small></p>`;
        html += `<table><tr><th>Hero</th><th>Base CI</th><th>Avg Actives</th><th>Avg CC Lost</th><th>Final ATK (avg [min‚Äìmax])</th><th>Final allDmg (avg [min‚Äìmax])</th><th>Peak CI during fight (avg [min‚Äìmax])</th><th>Avg mid-fight CI</th><th>DR R6-15 (avg [min‚Äìmax])</th><th>ADR R6-15 (avg [min‚Äìmax])</th><th>Final HD (avg [min‚Äìmax])</th></tr>`;
        for (let n in stats) {
            let s = stats[n];
            html += `<tr>
                <td>${n}</td>
                <td>${(s.baseCI*100).toFixed(0)}%</td>
                <td>${(s.acts/N).toFixed(2)}</td>
                <td>${(s.lost/N).toFixed(2)}</td>
                <td>${range(s.finalATK/N, s.minATK, s.maxATK)}</td>
                <td>${range(s.finalAllDmg/N, s.minAllDmg, s.maxAllDmg)}</td>
                <td>${range(s.peakCI/N, s.minPeakCI, s.maxPeakCI)}</td>
                <td><span style="color:var(--accent)">${(s.avgCI/N*100).toFixed(1)}%</span></td>

                <td>${range(s.avgDR/N, s.minDR === Infinity ? 0 : s.minDR, s.maxDR === -Infinity ? 0 : s.maxDR)}</td>
                <td>${range(s.avgADR/N, s.minADR === Infinity ? 0 : s.minADR, s.maxADR === -Infinity ? 0 : s.maxADR)}</td>

                <td>${range(s.finalHD/N, s.minHD, s.maxHD)}</td>
            </tr>`;
        }
        // Estimated fight damage line below table
        let dmgLine = '';
        const dmgEntry = Object.values(stats).find(s => s.totalEstDmg > 0);
        if (dmgEntry) {
            const s = dmgEntry;
            const fmt = v => Math.round(v/N).toLocaleString();
            const pct = (part, total) => total > 0 ? (part/total*100).toFixed(1)+'%' : '‚Äî';
            const tot = s.totalEstDmg / N;
            const mHeroName = document.getElementById(`h${parseInt(document.querySelector('input[name="max"]:checked').value)}`)?.value || "LFA";
            dmgLine = `<div style="margin-top:12px;padding:14px 16px;background:var(--card);border:1px solid #334155;border-radius:8px;font-size:13px;line-height:1.8;">
                <div>‚öîÔ∏è <strong>Estimated Fight Damage (Max ATK Hero)</strong> ‚Äî
                Avg: <span style="color:var(--accent);font-weight:bold">${Math.round(tot).toLocaleString()}</span>
                <small style="color:#64748b">[${Math.round(s.minEstDmg).toLocaleString()} ‚Äì ${Math.round(s.maxEstDmg).toLocaleString()}]</small></div>
                <div style="margin-top:6px;display:grid;grid-template-columns:repeat(5,1fr);gap:6px;font-size:12px;">
                    <div style="background:#1e293b;padding:8px;border-radius:6px;text-align:center;">
                        <div style="color:#94a3b8">${mHeroName==="DGN"?"Main Hit":"Hits 1-5"}</div>
                        <div style="color:var(--accent)">${fmt(s.srcHits + (s.srcMain||0))}</div>
                        <div style="color:#64748b">${pct(s.srcHits + (s.srcMain||0), s.totalEstDmg)}</div>
                    </div>
                    <div style="background:#1e293b;padding:8px;border-radius:6px;text-align:center;">
                        <div style="color:#94a3b8">${mHeroName==="DGN"?"Undying Shadow":"DKM"}</div>
                        <div style="color:var(--accent)">${fmt(mHeroName==="DGN"?(s.srcUndying||0):s.srcDKM)}</div>
                        <div style="color:#64748b">${pct(mHeroName==="DGN"?(s.srcUndying||0):s.srcDKM, s.totalEstDmg)}</div>
                    </div>
                    <div style="background:#1e293b;padding:8px;border-radius:6px;text-align:center;">
                        <div style="color:#94a3b8">Lethal Fightback</div>
                        <div style="color:var(--accent)">${fmt(s.srcLethal)}</div>
                        <div style="color:#64748b">${pct(s.srcLethal, s.totalEstDmg)}</div>
                    </div>
                    <div style="background:#1e293b;padding:8px;border-radius:6px;text-align:center;">
                        <div style="color:#94a3b8">Balanced Strike</div>
                        <div style="color:var(--accent)">${fmt(s.srcBS)}</div>
                        <div style="color:#64748b">${pct(s.srcBS, s.totalEstDmg)}</div>
                    </div>
                    <div style="background:#1e293b;padding:8px;border-radius:6px;text-align:center;">
                        <div style="color:#94a3b8">Addl. Multiplier</div>
                        <div style="color:var(--accent)">${fmt(s.srcAddl)}</div>
                        <div style="color:#64748b">${pct(s.srcAddl, s.totalEstDmg)}</div>
                    </div>
                </div>
            </div>`;
        }
        // ‚îÄ‚îÄ Per-round damage ramp chart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let roundChartHtml = '';
        const dmgEntry2 = Object.values(stats).find(s => s.dmgPerRound && s.dmgPerRound.some(d=>d>0));
        if (dmgEntry2) {
            const perRound = dmgEntry2.dmgPerRound.map(d => d / N); // avg per round
            // cumulative damage by end of each round
            const cumul = [];
            let running = 0;
            perRound.forEach(d => { running += d; cumul.push(running); });

            const maxCumul = cumul[14] || 1;
            const W = 580, H = 200, PAD = { t:20, r:20, b:36, l:65 };
            const cW = W - PAD.l - PAD.r;
            const cH = H - PAD.t - PAD.b;
            const toX = r  => PAD.l + (r / 14) * cW;
            const toY = v  => PAD.t + cH - (v / maxCumul) * cH;

            // Cumulative line
            const cumulPts = cumul.map((v,i) => `${toX(i).toFixed(1)},${toY(v).toFixed(1)}`).join(' ');
            // Per-round bars (normalised)
            const maxRound = Math.max(...perRound) || 1;
            const bars = perRound.map((d,i) => {
                const bH = (d / maxRound) * (cH * 0.35);
                const bX = toX(i) - 8;
                const bY = PAD.t + cH - bH;
                return `<rect x="${bX.toFixed(1)}" y="${bY.toFixed(1)}" width="16" height="${bH.toFixed(1)}" fill="#7c3aed" opacity="0.35"/>`;
            }).join('');

            // X axis labels
            const xLabels = Array.from({length:15},(_,i)=>i).map(i =>
                `<text x="${toX(i).toFixed(1)}" y="${PAD.t+cH+14}" text-anchor="middle" fill="#64748b" font-size="10">R${i+1}</text>`
            ).join('');

            // Y axis labels (4 ticks)
            const yLabels = [0,0.25,0.5,0.75,1].map(t => {
                const v = t * maxCumul;
                const y = toY(v);
                const label = v >= 1e18 ? (v/1e18).toFixed(1)+'Qi'
                            : v >= 1e15 ? (v/1e15).toFixed(1)+'Qa'
                            : v >= 1e12 ? (v/1e12).toFixed(1)+'T'
                            : v >= 1e9  ? (v/1e9).toFixed(1)+'B'
                            : v >= 1e6  ? (v/1e6).toFixed(1)+'M' : Math.round(v).toLocaleString();
                return `<line x1="${PAD.l}" y1="${y.toFixed(1)}" x2="${PAD.l+cW}" y2="${y.toFixed(1)}" stroke="#1e293b" stroke-width="1"/>
                        <text x="${PAD.l-5}" y="${(y+4).toFixed(1)}" text-anchor="end" fill="#64748b" font-size="10">${label}</text>`;
            }).join('');

            // Dot markers on cumulative line
            const dots = cumul.map((v,i) =>
                `<circle cx="${toX(i).toFixed(1)}" cy="${toY(v).toFixed(1)}" r="3" fill="#38bdf8"/>`
            ).join('');

            roundChartHtml = `<div style="margin-top:16px;padding:16px;background:var(--card);border:1px solid #334155;border-radius:8px;">
                <h4 style="color:#38bdf8;margin:0 0 10px">üìà Damage Ramp by Round (avg across ${N} fights)</h4>
                <svg width="${W}" height="${H}" style="display:block;overflow:visible">
                    ${yLabels}
                    ${bars}
                    <polyline points="${cumulPts}" fill="none" stroke="#38bdf8" stroke-width="2.5"/>
                    ${dots}
                    <line x1="${PAD.l}" y1="${PAD.t}" x2="${PAD.l}" y2="${PAD.t+cH}" stroke="#334155"/>
                    <line x1="${PAD.l}" y1="${PAD.t+cH}" x2="${PAD.l+cW}" y2="${PAD.t+cH}" stroke="#334155"/>
                    ${xLabels}
                    <text x="${PAD.l+cW/2}" y="${H-2}" text-anchor="middle" fill="#64748b" font-size="11">Round</text>
                    <text x="12" y="${PAD.t+cH/2}" text-anchor="middle" fill="#64748b" font-size="11" transform="rotate(-90,12,${PAD.t+cH/2})">Cumulative Dmg</text>
                    <line x1="${PAD.l+cW-130}" y1="${PAD.t+8}" x2="${PAD.l+cW-110}" y2="${PAD.t+8}" stroke="#38bdf8" stroke-width="2"/>
                    <text x="${PAD.l+cW-106}" y="${PAD.t+12}" fill="#38bdf8" font-size="10">Cumulative</text>
                    <rect x="${PAD.l+cW-130}" y="${PAD.t+18}" width="20" height="8" fill="#7c3aed" opacity="0.5"/>
                    <text x="${PAD.l+cW-106}" y="${PAD.t+26}" fill="#a78bfa" font-size="10">Per-round</text>
                </svg>
            </div>`;
        }
        out.innerHTML = html + `</table>` + dmgLine + roundChartHtml;
    }
}
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// OPTIMIZER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function triggerJadeToad(caster) {
    if (!units || units.length === 0) return;
    // 5√ó grant +3% AllDmg to random ally ‚Äî cap is 90% from Jade Toad specifically per ally
    for (let j = 0; j < 5; j++) {
        const target = units[Math.floor(Math.random() * units.length)];
        if ((target.jadeToadAllDmg || 0) < 0.90) {
            const grant = Math.min(0.03, 0.90 - (target.jadeToadAllDmg || 0));
            target.jadeToadAllDmg = (target.jadeToadAllDmg || 0) + grant;
            target.buffs.allDmg.push({ value: grant, rounds: 999, source: 'Jade Toad AllDmg' });
            if (!silent) log(`&nbsp;&nbsp;&nbsp;üê∏ [JADE TOAD] +${(grant*100).toFixed(0)}% AllDmg ‚Üí ${target.name} (Toad total: ${((target.jadeToadAllDmg)*100).toFixed(0)}%)`, '#4ade80');
        }
    }
    // Each ally: 33% chance +1 SPD 2r, 33% chance +1% ATK 2r (offsettable)
    units.forEach(target => {
        const roll = Math.random();
        if (roll < 0.333) {
            addBuff(target, 'spd', 1, 2, 'Jade Toad SPD');
        } else if (roll < 0.666) {
            addBuff(target, 'atk', 0.01, 2, 'Jade Toad ATK');
        }
    });
}

function runOptimizer() {
    const btn  = document.getElementById('optBtn');
    const prog = document.getElementById('optProgress');
    const out  = document.getElementById('optOutput');

    const dcPanel = document.getElementById('dmgCalcPanel');
    if (!dcPanel || dcPanel.style.display === 'none') {
        alert('Please open the Damage Calculator panel and fill in LFA\'s stats before running the optimizer.');
        return;
    }

    btn.disabled = true;
    btn.textContent = '‚è≥ Optimizing...';
    prog.style.display = 'block';
    out.innerHTML = '';

    const heroNames = Array.from({length:6}, (_,i) => document.getElementById(`h${i}`).value);
    const mIdx      = parseInt(document.querySelector('input[name="max"]:checked').value);
    const safeMode  = document.getElementById('safeMode')?.checked || false;
    // Per-hero base CI (artCI added per-build in display; voidCI explored per-build in optimizer)
    const heroCIs   = Array.from({length:6}, (_,i) => {
        const base = parseFloat(document.getElementById(`ci${i}`)?.value) || 0;
        return base; // voidCI and artCI added per-build
    });
    const heroUpgPurify = Array.from({length:6}, (_,i) => document.getElementById(`upgPurify${i}`)?.checked || false);
    // Which heroes have void CI eligible (checkbox checked in UI)
    // Void CI: always explore on/off for ALL STELLAR_HEROES in the team (ignore checkbox state)
    const eligIdx = [0,1,2,3,4,5].filter(i => STELLAR_HEROES.includes(heroNames[i]));
    const voidMasks = [];
    for (let mask = 0; mask < (1 << eligIdx.length); mask++) {
        const v = new Array(6).fill(false);
        eligIdx.forEach((hi, bit) => { if (mask & (1 << bit)) v[hi] = true; });
        voidMasks.push(v);
    }
    // Low HP hero names from dropdowns
    const lowhpNames = ['lowhp0','lowhp1','lowhp2']
        .map(id => { const v = document.getElementById(id)?.value; return v !== '' ? heroNames[parseInt(v)] : null; })
        .filter(Boolean);
    const sqhIdx    = heroNames.indexOf('SQH');
    const bdsmIdx   = heroNames.indexOf('BDSM');
    const others    = [0,1,2,3,4,5].filter(i => i!==mIdx && i!==sqhIdx && i!==bdsmIdx);

    const lfaArts   = ['Antiwarrior','Antlers','Scissors'];
    const otherArts = ['Demon Bell','Spiritual Mirror','Scissors'];

    // ‚îÄ‚îÄ Artifact combos ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function buildArtCombos() {
        const combos = [];
        const nonLfa = [0,1,2,3,4,5].filter(i => i !== mIdx);
        function recurse(k, arts) {
            if (k === nonLfa.length) {
                if (arts.filter(a => a === 'Scissors').length >= 2) combos.push([...arts]);
                return;
            }
            for (const a of otherArts) {
                arts[nonLfa[k]] = a;
                recurse(k + 1, arts);
            }
        }
        for (const la of lfaArts) {
            const arts = new Array(6);
            arts[mIdx] = la;
            recurse(0, arts);
        }
        return combos;
    }

    // ‚îÄ‚îÄ Speed orderings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


    // ‚îÄ‚îÄ Slot arrangements ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function buildSlotArrs() {
        const nonLfa = [0,1,2,3,4,5].filter(i => i !== mIdx);
        const arrs = [];
        function permute(arr) {
            if (arr.length <= 1) return [arr];
            return arr.flatMap((v,i) => permute([...arr.slice(0,i),...arr.slice(i+1)]).map(p=>[v,...p]));
        }
        for (let fi = 0; fi < nonLfa.length; fi++) {
            for (let fj = 0; fj < nonLfa.length; fj++) {
                if (fi === fj) continue;
                const front2 = [nonLfa[fi], nonLfa[fj]];
                const remaining3 = nonLfa.filter((_,k) => k!==fi && k!==fj);
                for (let lfaBackSlot = 0; lfaBackSlot <= 3; lfaBackSlot++) {
                    for (const perm of permute(remaining3)) {
                        const back4 = [...perm.slice(0, lfaBackSlot), mIdx, ...perm.slice(lfaBackSlot)];
                        arrs.push([...front2, ...back4]);
                    }
                }
            }
        }
        return arrs;
    }

    // ‚îÄ‚îÄ Helper: run N fights for a given config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function runFights(arts, spds, slotAssign, n, vCI) {
        let total = 0;
        for (let f = 0; f < n; f++) {
            const heroes = Array.from({length:6}, (_,slot) => {
                const hi = slotAssign[slot];
                return { name: heroNames[hi], art: arts[hi], spd: spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: (vCI||[])[hi]||false, upgradedPurify: heroUpgPurify[hi] };
            });
            { const _fr = runOne({ heroes, fromOptimizer: true }); total += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
        }
        return total / n;
    }

    const artCombos = buildArtCombos();
    const slotArrs  = buildSlotArrs();
    const defaultSlot = slotArrs[0];

    // ‚îÄ‚îÄ Phase 1: art √ó voidCI only (default speed + position) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Use user-inputted speeds directly
    const userSpds = Array.from({length:6}, (_,i) => parseInt(document.getElementById(`s${i}`).value) || (2000 - i*100));
    const phase1 = [];
    for (const arts of artCombos)
        for (const voidCI of voidMasks)
            phase1.push({ arts, spds: userSpds, slotAssign: defaultSlot, voidCI });

    prog.textContent = `Phase 1/6: scanning ${phase1.length.toLocaleString()} art√óvoidCI combos ‚Äî ${eligIdx.length} heroes with void CI explored (${voidMasks.length} CI masks √ó 3 fights each)...`;
    let p1idx = 0, p1results = [];
    const CHUNK = 300;

    function runPhase1Chunk() {
        silent = true;
        for (let end = Math.min(p1idx + CHUNK, phase1.length); p1idx < end; p1idx++) {
            const { arts, spds, slotAssign, voidCI: vCI1 } = phase1[p1idx];
            let dmgSum = 0;
            for (let f = 0; f < 3; f++) {
                const heroes = Array.from({length:6}, (_,slot) => {
                    const hi = slotAssign[slot];
                    return { name: heroNames[hi], art: arts[hi], spd: spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: (vCI1||[])[hi]||false, upgradedPurify: heroUpgPurify[hi] };
                });
                { const _fr = runOne({ heroes, fromOptimizer: true }); dmgSum += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
            }
            p1results.push({ dmg: dmgSum/3, arts:[...arts], spds:[...spds], slotAssign:[...slotAssign], voidCI:[...(vCI1||[])] });
        }
        silent = false;
        const pct = Math.round(p1idx/phase1.length*100);
        prog.textContent = `Phase 1/6: art√óvoidCI (3 fights) ‚Äî ${pct}% (${p1idx.toLocaleString()}/${phase1.length.toLocaleString()})`;
        if (p1idx < phase1.length) { requestAnimationFrame(runPhase1Chunk); return; }

        // ‚îÄ‚îÄ Phase 2: top 150 art√óspeed √ó all slot arrangements ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        p1results.sort((a,b) => b.dmg - a.dmg);
        const top80 = p1results.slice(0, 80);
        const phase2 = [];
        for (const r of top80)
            phase2.push({ arts: r.arts, spds: r.spds, slotAssign: defaultSlot, voidCI: r.voidCI });

        prog.textContent = `Phase 2/6: re-testing top 80 art√óvoidCI builds (1 fight each)...`;
        let p2idx = 0, p2results = [];

        function runPhase2Chunk() {
            silent = true;
            for (let end = Math.min(p2idx + CHUNK, phase2.length); p2idx < end; p2idx++) {
                const { arts, spds, slotAssign, voidCI: vCI2 } = phase2[p2idx];
                const sa = slotAssign;
                const heroes = Array.from({length:6}, (_,slot) => {
                    const hi = sa[slot];
                    return { name: heroNames[hi], art: arts[hi], spd: spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: (vCI2||[])[hi]||false, upgradedPurify: heroUpgPurify[hi] };
                });
                const res = runOne({ heroes, fromOptimizer: true });
                p2results.push({ dmg: res.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg||0, arts:[...arts], spds:[...spds], slotAssign:[...sa], voidCI:[...(vCI2||new Array(6).fill(false))] });
            }
            silent = false;
            const pct2 = Math.round(p2idx/phase2.length*100);
            prog.textContent = `Phase 2/6: re-testing ‚Äî ${pct2}% (${p2idx.toLocaleString()}/${phase2.length.toLocaleString()})`;
            if (p2idx < phase2.length) { requestAnimationFrame(runPhase2Chunk); return; }

            // ‚îÄ‚îÄ Phase 2.5: top 5 slot arrangements √ó all art√óspeed √ó 3 fights
            p2results.sort((a,b) => b.dmg - a.dmg);
            // Phase 2.5: top 30 art√óspeed builds √ó all slot arrangements
            p2results.sort((a,b) => b.dmg - a.dmg);
            const top30art = p2results.slice(0, 30);
            const phase15 = [];
            for (const r of top30art)
                for (const slotAssign of slotArrs)
                    phase15.push({ arts: r.arts, spds: r.spds, slotAssign, voidCI: r.voidCI });

            prog.textContent = `Phase 2.5/6: ${phase15.length.toLocaleString()} slot arrangements on top 30 builds (3 fights each)...`;
            let p15idx = 0, p15results = [];

            function runPhase15Chunk() {
                silent = true;
                for (let end = Math.min(p15idx + CHUNK, phase15.length); p15idx < end; p15idx++) {
                    const { arts, spds, slotAssign, voidCI } = phase15[p15idx];
                    let dmgSum = 0;
                    for (let f = 0; f < 3; f++) {
                        const heroes = Array.from({length:6}, (_,slot) => {
                            const hi = slotAssign[slot];
                            return { name: heroNames[hi], art: arts[hi], spd: spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: ((voidCI||[])[hi]||false), upgradedPurify: heroUpgPurify[hi] };
                        });
                        { const _fr = runOne({ heroes, fromOptimizer: true }); dmgSum += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
                    }
                    p15results.push({ dmg: dmgSum/3, arts:[...arts], spds:[...spds], slotAssign:[...slotAssign], voidCI:[...(voidCI||[])] });
                }
                silent = false;
                const pct15 = Math.round(p15idx/phase15.length*100);
                prog.textContent = `Phase 2.5/6: slot arrangements ‚Äî ${pct15}% (${p15idx.toLocaleString()}/${phase15.length.toLocaleString()})`;
                if (p15idx < phase15.length) { requestAnimationFrame(runPhase15Chunk); return; }

                // ‚îÄ‚îÄ Phase 2.6: crit sweep on top 50 builds ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                p15results.sort((a,b) => b.dmg - a.dmg);

                // ‚îÄ‚îÄ Phase 2.7 (optional): speed permutation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const relaxSpeeds = document.getElementById('relaxSpeeds')?.checked;
                function permuteArr(arr) {
                    if (arr.length <= 1) return [arr];
                    return arr.flatMap((v,i) => permuteArr([...arr.slice(0,i),...arr.slice(i+1)]).map(p=>[v,...p]));
                }
                const speedPerms = relaxSpeeds ? permuteArr([...userSpds]) : [[...userSpds]];

                const top50base = p15results.slice(0, 30);
                let p27results = [];

                if (!relaxSpeeds || speedPerms.length <= 1) {
                    // No speed relaxation ‚Äî skip phase 2.7
                    p27results = top50base.map(r => ({...r}));
                    startCritSweep();
                } else {
                    const phase27 = [];
                    for (const r of top50base)
                        for (const sperm of speedPerms)
                            phase27.push({ ...r, spds: sperm });
                    prog.textContent = `Phase 2.7: speed permutations ‚Äî ${phase27.length.toLocaleString()} combos (1 fight each)...`;
                    let p27idx = 0;
                    function runPhase27Chunk() {
                        silent = true;
                        for (let end = Math.min(p27idx + CHUNK, phase27.length); p27idx < end; p27idx++) {
                            const rb = phase27[p27idx];
                            const heroes = Array.from({length:6}, (_,slot) => {
                                const hi = rb.slotAssign[slot];
                                return { name: heroNames[hi], art: rb.arts[hi], spd: rb.spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: ((rb.voidCI||[])[hi]||false), upgradedPurify: heroUpgPurify[hi] };
                            });
                            const dmg = runOne({ heroes, fromOptimizer: true }).units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0;
                            p27results.push({ ...rb, dmg });
                        }
                        silent = false;
                        prog.textContent = `Phase 2.7: speed perms ‚Äî ${Math.round(p27idx/phase27.length*100)}% (${p27idx.toLocaleString()}/${phase27.length.toLocaleString()})`;
                        if (p27idx < phase27.length) { requestAnimationFrame(runPhase27Chunk); return; }
                        p27results.sort((a,b) => b.dmg - a.dmg);
                        p27results = p27results.slice(0, 30);
                        startCritSweep();
                    }
                    requestAnimationFrame(runPhase27Chunk);
                }

                function startCritSweep() {
                const top50 = p27results.slice(0, 30);
                prog.textContent = `Phase 2.6: finding optimal crit % for top ${top50.length} builds...`;
                const critInput = document.getElementById('dc_crit');
                const origCrit  = critInput.value;
                let csIdx = 0;
                let p3idx = 0, p3results = [];
                function runCritSweep() {
                    if (csIdx >= top50.length) {
                        critInput.value = origCrit;
                        // ‚îÄ‚îÄ Phase 3: top 50 √ó 300 fights ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        prog.textContent = `Phase 3/6: re-testing top 30 builds (100 fights each)...`;
                        requestAnimationFrame(runPhase3Chunk);
                        return;
                    }
                    // Sweep crit 0‚Äì100 for this build (10 fights per step = 1010 fights)
                    const rb = top50[csIdx];
                    let bestCrit = parseInt(origCrit) || 0, bestDmg = -1;
                    for (let crit = 0; crit <= 100; crit += 5) {
                        critInput.value = crit;
                        let tot = 0;
                        silent = true;
                        for (let f = 0; f < 10; f++) {
                            const heroes = Array.from({length:6}, (_,slot) => {
                                const hi = rb.slotAssign[slot];
                                return { name: heroNames[hi], art: rb.arts[hi], spd: rb.spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: (rb.voidCI||[])[hi]||false, upgradedPurify: heroUpgPurify[hi] };
                            });
                            { const _fr = runOne({ heroes, fromOptimizer: true }); tot += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
                        }
                        silent = false;
                        if (tot > bestDmg) { bestDmg = tot; bestCrit = crit; }
                    }
                    rb.optimalCrit = bestCrit;
                    prog.textContent = `Phase 2.6: crit sweep ${csIdx+1}/${top50.length} ‚Äî optimal crit: ${bestCrit}% (${Math.round((csIdx+1)/top50.length*100)}%)`;
                    csIdx++;
                    requestAnimationFrame(runCritSweep);
                }

                        function runPhase3Chunk() {
                    if (p3idx >= top50.length) {
                        // ‚îÄ‚îÄ Phase 4: top 20 √ó 300 fights ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        p3results.sort((a,b) => b.avgDmg - a.avgDmg);
                        const top20 = p3results.slice(0, 20);
                        prog.textContent = `Phase 4/6: re-testing top 20 builds (100 fights each)...`;
                                            let p4idx = 0, p4results = [];

                        function runPhase4Chunk() {
                            if (p4idx >= top20.length) {
                                // ‚îÄ‚îÄ Phase 5: top 10 √ó 300 fights ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                                p4results.sort((a,b) => b.avgDmg - a.avgDmg);
                                const top10 = p4results.slice(0, 10);
                                prog.textContent = `Phase 5/6: top 10 (100 fights each)...`;
                                                            let p5idx = 0, p5results = [];

                                function runPhase5Chunk() {
                                    if (p5idx >= top10.length) {
                                        p5results.sort((a,b) => b.avgDmg - a.avgDmg);
                                        // ‚îÄ‚îÄ Phase 6: optimal crit sweep per top-10 build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                                        prog.textContent = 'Phase 6/6: sweeping optimal crit % for each top-10 build...';
                                        runPhase6(p5results, heroNames, mIdx, heroCIs, lowhpNames, btn, prog);
                                        return;
                                    }
                                    const r = top10[p5idx];
                                    silent = true;
                                    let total = 0, minDmg = Infinity, maxDmg = -Infinity;
                                    critInput.value = r.optimalCrit ?? origCrit;
                                    for (let f = 0; f < 100; f++) {
                                        const heroes = Array.from({length:6}, (_,slot) => {
                                            const hi = r.slotAssign[slot];
                                            return { name: heroNames[hi], art: r.arts[hi], spd: r.spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: ((r.voidCI||[])[hi]||false), upgradedPurify: heroUpgPurify[hi] };
                                        });
                                        const _fr = runOne({ heroes, fromOptimizer: true });
                                        const d = (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0);
                                        total += d;
                                        if (d < minDmg) minDmg = d;
                                        if (d > maxDmg) maxDmg = d;
                                    }
                                    silent = false;
                                    critInput.value = origCrit;
                                        p5results.push({ ...r, avgDmg: total/100, minDmg, maxDmg, voidCI: r.voidCI, optimalCrit: r.optimalCrit });
                                    prog.textContent = `Phase 5/6: top 10 ‚Äî ${p5idx+1}/10 done`;
                                    p5idx++;
                                    requestAnimationFrame(runPhase5Chunk);
                                }
                                requestAnimationFrame(runPhase5Chunk);
                                return;
                            }
                            const r = top20[p4idx];
                            silent = true;
                            let total = 0;
                            critInput.value = r.optimalCrit ?? origCrit;
                            for (let f = 0; f < 100; f++) {
                                const heroes = Array.from({length:6}, (_,slot) => {
                                    const hi = r.slotAssign[slot];
                                    return { name: heroNames[hi], art: r.arts[hi], spd: r.spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: ((r.voidCI||[])[hi]||false), upgradedPurify: heroUpgPurify[hi] };
                                });
                                { const _fr = runOne({ heroes, fromOptimizer: true }); total += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
                            }
                            silent = false;
                            critInput.value = origCrit;
                                p4results.push({ ...r, avgDmg: total/100, voidCI: r.voidCI, optimalCrit: r.optimalCrit });
                            prog.textContent = `Phase 4/6: top 20 ‚Äî ${p4idx+1}/20 done`;
                            p4idx++;
                            requestAnimationFrame(runPhase4Chunk);
                        }
                        requestAnimationFrame(runPhase4Chunk);
                        return;
                    }
                    const r = top50[p3idx];
                    silent = true;
                    let total = 0;
                    critInput.value = r.optimalCrit ?? origCrit;
                    for (let f = 0; f < 100; f++) {
                        const heroes = Array.from({length:6}, (_,slot) => {
                            const hi = r.slotAssign[slot];
                            return { name: heroNames[hi], art: r.arts[hi], spd: r.spds[hi], isFr: slot < 2, cardIdx: hi, voidCI: ((r.voidCI||[])[hi]||false), upgradedPurify: heroUpgPurify[hi] };
                        });
                        { const _fr = runOne({ heroes, fromOptimizer: true }); total += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0); }
                    }
                    silent = false;
                    p3results.push({ ...r, avgDmg: total/100, voidCI: r.voidCI, optimalCrit: r.optimalCrit });
                    prog.textContent = `Phase 3/6: top 30 ‚Äî ${p3idx+1}/30 done`;
                    p3idx++;
                    requestAnimationFrame(runPhase3Chunk);
                }
                requestAnimationFrame(runPhase3Chunk);
                } // end startCritSweep
            }
            requestAnimationFrame(runPhase15Chunk);
        }
        requestAnimationFrame(runPhase2Chunk);
    }
    requestAnimationFrame(runPhase1Chunk);
}


// ‚îÄ‚îÄ Phase 6: per-build optimal crit sweep ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runPhase6(builds, heroNames, mIdx, heroCIs, lowhpNames, btn, prog) {
    const critInput  = document.getElementById('dc_crit');
    const safeMode   = document.getElementById('safeMode')?.checked || false;
    const origCrit   = critInput.value;
    const FINAL_N    = 100;
    const CI_N       = 50;
    const CI_DELTAS  = [-35, -20, -10, +10, +20, +35];

    let bIdx = 0;
    // step: 0 = baseline, 1-6 = CI deltas
    let step = 0;

    function buildHeroes(r, slot) {
        const hi = r.slotAssign[slot];
        return { name: heroNames[hi], art: r.arts[hi], spd: r.spds[hi],
                 isFr: slot < 2, cardIdx: hi, voidCI: (r.voidCI||[])[hi]||false, upgradedPurify: heroUpgPurify[hi] };
    }

    function runNFights(r, n, ciOverride) {
        const ciInput = document.getElementById(`ci${mIdx}`);
        const origCI  = ciInput.value;
        if (ciOverride != null) ciInput.value = Math.max(0, parseFloat(origCI) + ciOverride);
        let total = 0;
        silent = true;
        for (let f = 0; f < n; f++) {
            const heroes = Array.from({length:6}, (_,slot) => buildHeroes(r, slot));
            const _fr = runOne({ heroes, fromOptimizer: true });
            total += (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0);
        }
        silent = false;
        if (ciOverride != null) ciInput.value = origCI;
        return total / n;
    }

    function sweepStep() {
        if (bIdx >= builds.length) {
            critInput.value = origCrit;
            builds.sort((a,b) => (b.phase6Dmg ?? b.avgDmg) - (a.phase6Dmg ?? a.avgDmg));
            finishOptimizer(builds, heroNames, mIdx, heroCIs, lowhpNames);
            btn.disabled = false;
            btn.textContent = '‚ö° Find Optimal Build';
            prog.style.display = 'none';
            return;
        }

        const r = builds[bIdx];
        const useCrit = r.optimalCrit ?? (parseInt(origCrit) || 0);
        critInput.value = useCrit;

        if (step === 0) {
            // Baseline fights
            prog.textContent = `Phase 6/6: build ${bIdx+1}/${builds.length} ‚Äî baseline ${FINAL_N} fights`;
            r.ciSensitivity = {};
            const distDmgs = [];
            silent = true;
            let total = 0;
            for (let f = 0; f < FINAL_N; f++) {
                const heroes = Array.from({length:6}, (_,slot) => buildHeroes(r, slot));
                const _fr = runOne({ heroes, fromOptimizer: true });
                const d = (safeMode && _fr.shrinkMissed) ? 0 : (_fr.units.find(u=>u.name===heroNames[mIdx])?.totalEstDmg || 0);
                total += d;
                distDmgs.push(d);
            }
            silent = false;
            r.phase6Dmg = total / FINAL_N;
            r.dmgDistribution = {};
            for (const d of distDmgs) {
                if (d <= 0) continue;
                const mag = Math.floor(Math.log10(d));
                r.dmgDistribution[mag] = (r.dmgDistribution[mag] || 0) + 1;
            }
            step = 1;
        } else {
            // CI sensitivity step
            const delta = CI_DELTAS[step - 1];
            prog.textContent = `Phase 6/6: build ${bIdx+1}/${builds.length} ‚Äî CI ${delta > 0 ? '+' : ''}${delta} sensitivity (${step}/${CI_DELTAS.length})`;
            const avg = runNFights(r, CI_N, delta);
            r.ciSensitivity[delta] = avg - r.phase6Dmg;
            step++;
            if (step > CI_DELTAS.length) {
                // Done with this build
                prog.textContent = `Phase 6/6: build ${bIdx+1}/${builds.length} ‚Äî crit: ${useCrit}% ‚Üí ${Math.round(r.phase6Dmg).toLocaleString()}`;
                bIdx++;
                step = 0;
            }
        }

        requestAnimationFrame(sweepStep);
    }

    requestAnimationFrame(sweepStep);
}

function finishOptimizer(results, heroNames, mIdx, heroCIs, lowhpNames) {
    // Sort by avgDmg (500-fight average) descending ‚Äî this is the only correct sort
    results.sort((a,b) => (b.phase6Dmg ?? b.avgDmg) - (a.phase6Dmg ?? a.avgDmg));

    const fmt = v => v > 0 ? Math.round(v).toLocaleString() : '‚Äî';
    const artColors = {
        'Antiwarrior': '#f59e0b', 'Antlers': '#4ade80',
        'Scissors': '#38bdf8', 'Demon Bell': '#ec4899',
        'Spiritual Mirror': '#a78bfa'
    };
    const badge = (art) => `<span style="background:${artColors[art]||'#475569'}22;color:${artColors[art]||'#94a3b8'};border:1px solid ${artColors[art]||'#475569'}44;padding:1px 6px;border-radius:4px;font-size:11px">${art}</span>`;

    let html = `<div style="margin-top:16px">
    <h3 style="color:#a78bfa;margin-bottom:12px">‚ö° Top 10 Optimal Builds (Phase 6: optimal crit √ó 100 fights)</h3>
    <table style="width:100%;border-collapse:collapse;font-size:12px">
    <thead><tr style="background:#1e293b;color:#94a3b8">
        <th style="padding:8px;text-align:left">#</th>
        <th style="padding:8px;text-align:left">Avg Damage (300 fights)</th>
        <th style="padding:8px;text-align:left">Acting Order</th>
        <th style="padding:8px;text-align:left">Slot 1‚Üí6 (1-2 Front ¬∑ Artifact ¬∑ CI)</th>
    </tr></thead><tbody>`;
    const lowhpBadge = lowhpNames && lowhpNames.length ? `<div style="color:#64748b;font-size:11px;margin-bottom:6px">Low HP: ${lowhpNames.join(', ')}</div>` : '';
    html = html.replace('</h3>', '</h3>' + lowhpBadge);

    results.forEach((r, rank) => {
        const spdOrder = Array.from({length:6},(_,i)=>i).sort((a,b) => r.spds[b] - r.spds[a]);
        const actingOrder = spdOrder.map(i => heroNames[i]).join(' ‚Üí ');
        const slotStr = r.slotAssign.map((hi, slot) => {
            const ci = heroCIs ? heroCIs[hi] : null;
            const artName = r.arts[hi];
            const artCI = artName === 'Spiritual Mirror' ? 20 : artName === 'Scissors' ? 24 : artName === 'Jade Toad' ? 32 : 0;
            const voidOn = r.voidCI && r.voidCI[hi];
            const effCI = ci != null ? (ci + artCI + (voidOn ? 35 : 0)) : null;
            const ciTag = effCI != null ? `<span style="color:#38bdf8;font-size:10px"> ${effCI}%CI</span>` : '';
            return `<span style="color:#64748b;font-size:10px">${slot+1}.</span> ` +
                `<span style="color:${slot<2?'#f87171':'#94a3b8'}">${heroNames[hi]}</span> ` +
                badge(r.arts[hi]) + ciTag;
        }).join('<span style="color:#1e293b"> | </span>');
        // Void CI imprint summary line
        const voidOnHeroes = r.slotAssign
            .map(hi => ({ name: heroNames[hi], on: r.voidCI && r.voidCI[hi] }))
            .filter(x => STELLAR_HEROES.includes(x.name));
        const imprintStr = voidOnHeroes.length > 0
            ? voidOnHeroes.map(x =>
                `<span style="color:${x.on?'#a78bfa':'#64748b'};font-size:11px">${x.name}: ${x.on?'‚ú¶ Void CI ON':'Void CI OFF'}</span>`
              ).join(' &nbsp;')
            : '';

        const rowBg = rank === 0 ? '#172033' : 'transparent';
        const dmgColor = rank === 0 ? '#4ade80' : 'var(--accent)';
        const rangeStr = (r.minDmg != null && r.maxDmg != null)
            ? `<div style="color:#64748b;font-size:10px;margin-top:2px">Range: ${fmt(r.minDmg)} ‚Äì ${fmt(r.maxDmg)}</div>`
            : '';
        html += `<tr style="background:${rowBg};border-bottom:1px solid #1e293b">
            <td style="padding:8px;color:#64748b;font-weight:bold">${rank+1}</td>
            <td style="padding:8px;white-space:nowrap">
                <div style="color:${dmgColor};font-weight:bold">${fmt(r.phase6Dmg != null ? r.phase6Dmg : r.avgDmg)}</div>
                ${r.phase6Dmg != null ? `<div style="color:#a78bfa;font-size:11px">Optimal Crit: ${r.optimalCrit}%</div>` : ''}
                ${r.phase6Dmg != null ? `<div style="color:#64748b;font-size:10px">Phase 5 avg: ${fmt(r.avgDmg)}</div>` : ''}
                ${rangeStr}
                ${(() => {
                    if (!r.dmgDistribution || Object.keys(r.dmgDistribution).length === 0) return '';
                    const total = Object.values(r.dmgDistribution).reduce((a,b)=>a+b,0);
                    const mags = Object.keys(r.dmgDistribution).map(Number).sort((a,b)=>b-a);
                    return '<div style="margin-top:4px">' +
                        mags.map(mag => {
                            const count = r.dmgDistribution[mag];
                            const pct = (count/total*100).toFixed(0);
                            const bar = Math.round(count/total*30);
                            const barStr = '‚ñà'.repeat(bar) + '‚ñë'.repeat(30-bar);
                            const col = mag >= 23 ? '#4ade80' : mag >= 22 ? '#a78bfa' : mag >= 21 ? '#38bdf8' : '#94a3b8';
                            return '<div style="font-size:10px;color:'+col+';font-family:monospace">e'+mag+': '+pct+'% ('+count+'/'+total+')</div>';
                        }).join('') +
                    '</div>';
                })()}
            </td>
            <td style="padding:8px;color:#e2e8f0;white-space:nowrap">${actingOrder}</td>
            <td style="padding:8px;line-height:2">
                ${slotStr}
                ${imprintStr ? `<div style="margin-top:4px;display:flex;flex-wrap:wrap;gap:6px">${imprintStr}</div>` : ''}
                ${(() => {
                    if (!r.ciSensitivity) return '';
                    const s = r.ciSensitivity;
                    const fmtD = d => {
                        const sign = d >= 0 ? '+' : '';
                        const col = d > 0 ? '#4ade80' : d < 0 ? '#f87171' : '#64748b';
                        return `<span style="color:${col}">${sign}${Math.round(d).toLocaleString()}</span>`;
                    };
                    const baseDmg = r.phase6Dmg ?? r.avgDmg;
                    return `<div style="margin-top:6px;font-size:10px;color:#64748b">
                        <span style="color:#94a3b8;font-weight:bold">CI Sensitivity (${heroNames[mIdx]}):</span>
                        <table style="margin-top:3px;border-collapse:collapse;font-size:10px">
                            <tr style="color:#64748b">
                                <td style="padding:1px 6px">CI delta</td>
                                ${[-35,-20,-10,+10,+20,+35].map(d=>`<td style="padding:1px 6px;text-align:center">${d>0?'+':''}${d}</td>`).join('')}
                            </tr>
                            <tr>
                                <td style="padding:1px 6px;color:#64748b">Dmg delta</td>
                                ${[-35,-20,-10,+10,+20,+35].map(d=>`<td style="padding:1px 6px;text-align:center">${fmtD(s[d]??0)}</td>`).join('')}
                            </tr>
                            <tr>
                                <td style="padding:1px 6px;color:#64748b">% change</td>
                                ${[-35,-20,-10,+10,+20,+35].map(d=>{
                                    const pct = baseDmg > 0 ? ((s[d]??0)/baseDmg*100) : 0;
                                    const col = pct > 0 ? '#4ade80' : pct < 0 ? '#f87171' : '#64748b';
                                    return `<td style="padding:1px 6px;text-align:center;color:${col}">${pct>=0?'+':''}${pct.toFixed(1)}%</td>`;
                                }).join('')}
                            </tr>
                        </table>
                    </div>`;
                })()}
            </td>
        </tr>`;
    });

    html += `</tbody></table>
    <p style="color:#64748b;font-size:11px;margin-top:8px">
        Phase 1: art√óspeed√óvoidCI (3 fights) ‚Üí Phase 2: slot arrangements ‚Üí Phase 2.5: re-test positions ‚Üí Phases 3-5: progressive 300-fight refinement ‚Üí Phase 6: crit sweep (0-100%, 30 fights each) then 100 fights at optimal crit. Final ranking by Phase 6 damage. Red = frontline, grey = backline.
    </p></div>`;

    document.getElementById('optOutput').innerHTML = html;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CRIT % OPTIMIZER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function runCritOptimizer() {
    const btn  = document.getElementById('critOptBtn');
    const prog = document.getElementById('critOptProgress');
    const out  = document.getElementById('critOptOutput');

    // Check damage calc panel is open
    const dcPanel = document.getElementById('dmgCalcPanel');
    if (!dcPanel || dcPanel.style.display === 'none') {
        alert('Please open the Damage Calculator panel and fill in LFA\'s stats before running the crit optimizer.');
        return;
    }

    btn.disabled = true;
    btn.textContent = '‚è≥ Optimizing...';
    prog.style.display = 'block';
    out.innerHTML = '';

    const mIdx = parseInt(document.querySelector('input[name="max"]:checked').value);
    const FIGHTS_PER_VALUE = 100;
    const results = []; // { crit, avgDmg }

    // Sweep crit 0% to 100% in 1% steps
    const critValues = Array.from({length: 101}, (_, i) => i); // 0..100

    let ci = 0; // current crit index

    function runNextCrit() {
        if (ci >= critValues.length) {
            finishCritOptimizer(results, mIdx);
            btn.disabled = false;
            btn.textContent = 'üéØ Optimal Crit %';
            prog.style.display = 'none';
            return;
        }

        const critPct = critValues[ci];
        // Temporarily override the crit input
        const critInput = document.getElementById('dc_crit');
        const origCrit = critInput.value;
        critInput.value = critPct;

        let total = 0;
        silent = true;
        for (let f = 0; f < FIGHTS_PER_VALUE; f++) {
            const res = runOne();
            total += res.units[mIdx]?.totalEstDmg || 0;
        }
        silent = false;

        critInput.value = origCrit; // restore
        results.push({ crit: critPct, avgDmg: total / FIGHTS_PER_VALUE });

        const pct = Math.round((ci + 1) / critValues.length * 100);
        prog.textContent = `Sweeping crit %... ${critPct}% tested | ${pct}% complete`;

        ci++;
        requestAnimationFrame(runNextCrit);
    }

    requestAnimationFrame(runNextCrit);
}

function finishCritOptimizer(results, mIdx) {
    const out = document.getElementById('critOptOutput');

    // Find optimum
    const best = results.reduce((a, b) => b.avgDmg > a.avgDmg ? b : a);
    const maxDmg = Math.max(...results.map(r => r.avgDmg));
    const minDmg = Math.min(...results.map(r => r.avgDmg));
    const dmgRange = maxDmg - minDmg || 1;

    const fmt = v => Math.round(v).toLocaleString();

    // Build SVG chart
    const W = 600, H = 220, PAD = { t:20, r:20, b:40, l:60 };
    const cW = W - PAD.l - PAD.r;
    const cH = H - PAD.t - PAD.b;

    const toX = crit => PAD.l + (crit / 100) * cW;
    const toY = dmg  => PAD.t + cH - ((dmg - minDmg) / dmgRange) * cH;

    // Polyline points
    const pts = results.map(r => `${toX(r.crit).toFixed(1)},${toY(r.avgDmg).toFixed(1)}`).join(' ');

    // X-axis labels every 10%
    const xLabels = Array.from({length:11}, (_,i) => i*10).map(v =>
        `<text x="${toX(v)}" y="${PAD.t+cH+18}" text-anchor="middle" fill="#64748b" font-size="10">${v}%</text>`
    ).join('');

    // Y-axis labels (3 ticks)
    const yLabels = [0, 0.5, 1].map(t => {
        const dmgVal = minDmg + t * dmgRange;
        const y = toY(dmgVal);
        return `<text x="${PAD.l-6}" y="${y+4}" text-anchor="end" fill="#64748b" font-size="10">${Math.round(dmgVal/1e9).toFixed(1)}B</text>
                <line x1="${PAD.l}" y1="${y}" x2="${PAD.l+cW}" y2="${y}" stroke="#1e293b" stroke-width="1"/>`;
    }).join('');

    // Best marker
    const bx = toX(best.crit), by = toY(best.avgDmg);

    // Balanced Strike boundary ‚Äî probability BS fires = 1 - (crit/100)^numHits
    // At boss HP 50-59%: 5 hits. Show BS probability on secondary axis as dashed line
    const bsPts = results.map(r => {
        const bsProb = 1 - Math.pow(r.crit/100, 5);
        const bsY = PAD.t + cH - bsProb * cH; // scale 0-100% probability to chart height
        return `${toX(r.crit).toFixed(1)},${bsY.toFixed(1)}`;
    }).join(' ');

    const svgChart = `<svg width="${W}" height="${H}" style="display:block;margin:0 auto;overflow:visible">
        <!-- grid -->
        ${yLabels}
        <!-- BS probability dashed line -->
        <polyline points="${bsPts}" fill="none" stroke="#f59e0b" stroke-width="1.5" stroke-dasharray="4,3" opacity="0.5"/>
        <!-- damage line -->
        <polyline points="${pts}" fill="none" stroke="#38bdf8" stroke-width="2.5"/>
        <!-- best marker -->
        <circle cx="${bx}" cy="${by}" r="6" fill="#4ade80" stroke="#fff" stroke-width="1.5"/>
        <line x1="${bx}" y1="${PAD.t}" x2="${bx}" y2="${PAD.t+cH}" stroke="#4ade80" stroke-width="1" stroke-dasharray="3,3"/>
        <text x="${bx}" y="${PAD.t-6}" text-anchor="middle" fill="#4ade80" font-size="11" font-weight="bold">${best.crit}% optimal</text>
        <!-- axes -->
        <line x1="${PAD.l}" y1="${PAD.t}" x2="${PAD.l}" y2="${PAD.t+cH}" stroke="#334155" stroke-width="1"/>
        <line x1="${PAD.l}" y1="${PAD.t+cH}" x2="${PAD.l+cW}" y2="${PAD.t+cH}" stroke="#334155" stroke-width="1"/>
        ${xLabels}
        <text x="${PAD.l+cW/2}" y="${H-2}" text-anchor="middle" fill="#64748b" font-size="11">Pre-Battle Crit %</text>
        <text x="12" y="${PAD.t+cH/2}" text-anchor="middle" fill="#64748b" font-size="11" transform="rotate(-90,12,${PAD.t+cH/2})">Avg Damage</text>
        <!-- legend -->
        <line x1="${PAD.l+cW-120}" y1="${PAD.t+8}" x2="${PAD.l+cW-100}" y2="${PAD.t+8}" stroke="#38bdf8" stroke-width="2"/>
        <text x="${PAD.l+cW-96}" y="${PAD.t+12}" fill="#38bdf8" font-size="10">Avg Damage</text>
        <line x1="${PAD.l+cW-120}" y1="${PAD.t+22}" x2="${PAD.l+cW-100}" y2="${PAD.t+22}" stroke="#f59e0b" stroke-width="1.5" stroke-dasharray="4,3"/>
        <text x="${PAD.l+cW-96}" y="${PAD.t+26}" fill="#f59e0b" font-size="10">BS Proc Rate</text>
    </svg>`;

    // Top 5 table
    const sorted = [...results].sort((a,b) => b.avgDmg - a.avgDmg).slice(0,5);
    const tableRows = sorted.map((r, i) => {
        const bsProb = (1 - Math.pow(r.crit/100, 5)) * 100;
        const color = i === 0 ? '#4ade80' : 'var(--accent)';
        return `<tr style="border-bottom:1px solid #1e293b">
            <td style="padding:6px 10px;color:#64748b">${i+1}</td>
            <td style="padding:6px 10px;color:${color};font-weight:bold">${r.crit}%</td>
            <td style="padding:6px 10px;color:var(--accent)">${fmt(r.avgDmg)}</td>
            <td style="padding:6px 10px;color:#f59e0b">${bsProb.toFixed(1)}%</td>
        </tr>`;
    }).join('');

    out.innerHTML = `<div style="margin-top:16px;padding:16px;background:var(--card);border:1px solid #334155;border-radius:8px;">
        <h3 style="color:#0ea5e9;margin:0 0 4px">üéØ Optimal Pre-Battle Crit %</h3>
        <p style="color:#64748b;font-size:12px;margin:0 0 14px">
            Sweeping 0‚Äì100% crit in 1% steps √ó 100 fights each. Crit DMG %, Holy, AllDmg and all other stats held at current damage calculator values.
            <br>Tradeoff: higher crit = stronger hits but fewer Balanced Strike procs (fires when any of the 5 hits misses crit).
        </p>
        ${svgChart}
        <div style="margin-top:16px;display:flex;align-items:center;gap:24px;padding:12px;background:#0f172a;border-radius:8px;">
            <div><div style="color:#64748b;font-size:11px">Optimal Crit %</div><div style="color:#4ade80;font-size:22px;font-weight:bold">${best.crit}%</div></div>
            <div><div style="color:#64748b;font-size:11px">Avg Damage at Optimum</div><div style="color:#4ade80;font-size:18px;font-weight:bold">${fmt(best.avgDmg)}</div></div>
            <div><div style="color:#64748b;font-size:11px">BS Proc Rate at Optimum</div><div style="color:#f59e0b;font-size:18px;font-weight:bold">${((1-Math.pow(best.crit/100,5))*100).toFixed(1)}%</div></div>
            <div><div style="color:#64748b;font-size:11px">Damage vs 100% Crit</div>
                <div style="color:${best.crit<100?'#4ade80':'#64748b'};font-size:18px;font-weight:bold">
                    ${best.crit < 100 ? '+' + (((best.avgDmg - (results[100]?.avgDmg||best.avgDmg)) / (results[100]?.avgDmg||1))*100).toFixed(1) + '%' : 'N/A'}
                </div>
            </div>
        </div>
        <table style="width:100%;margin-top:12px;border-collapse:collapse;font-size:12px">
            <thead><tr style="background:#1e293b;color:#94a3b8">
                <th style="padding:6px 10px;text-align:left">#</th>
                <th style="padding:6px 10px;text-align:left">Crit %</th>
                <th style="padding:6px 10px;text-align:left">Avg Damage</th>
                <th style="padding:6px 10px;text-align:left">BS Proc Rate</th>
            </tr></thead>
            <tbody>${tableRows}</tbody>
        </table>
        <p style="color:#475569;font-size:11px;margin-top:8px">100 fights per crit value. Chart Y-axis normalized to damage range. Orange dashed = Balanced Strike proc probability.</p>
    </div>`;
}

// ‚îÄ‚îÄ Update damage calc label dynamically ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateDCLabel() {
    const mIdx = parseInt(document.querySelector('input[name="max"]:checked')?.value || 0);
    const heroName = document.getElementById(`h${mIdx}`)?.value || 'Max ATK Hero';
    const lbl = document.getElementById('dcHeroLabel');
    if (lbl) lbl.textContent = heroName;
}

// ‚îÄ‚îÄ DGN helper: count unique Attribute Reduction types on boss ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getDGNAttrCount() {
    let count = 0;
    if ((boss.atkDebuff   || 0) > 0) count++;
    if ((boss.armorDebuff || 0) > 0) count++;
    if ((boss.drDebuff    || 0) > 0) count++;
    if ((boss.ciDebuff    || 0) > 0) count++;
    if ((boss.spdDebuff   || 0) > 0) count++;
    if ((boss.critDebuff  || 0) > 0) count++;
    if ((boss.healReduction||0) > 0) count++;
    return count;
}

// ‚îÄ‚îÄ DGN Battle Start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function initDGN(units) {
    const dgn = units.find(u => u.name === 'DGN');
    if (!dgn) return;
    // Undying Shadow on boss (boss flag)
    boss.undyingShadow = true;
    log(`üåë [DGN INIT] Undying Shadow applied to boss`, '#c084fc');
    // Bright Blessing on highest ATK ally (isM)
    const bb = units.find(u => u.isM) || dgn;
    bb.brightBlessing = true;
    dgn.brightBlessingTarget = bb;
    log(`‚ú® [DGN INIT] Bright Blessing ‚Üí ${bb.name}`, '#c084fc');
    // Acheron Barque: +10% CI Offset to highest ATK ally (permanent, non-stacking)
    if (!bb.dgnAcheronApplied) {
        bb.dgnAcheronApplied = true;
        addBuff(bb, 'drOffset', 0.10, 999, 'DGN Acheron Barque CI Offset');
        log(`‚ú® [DGN ACHERON BARQUE] ${bb.name} +10% CI Offset (permanent)`, '#c084fc');
    }
    // Excellent Twins: HP+8%, ATK+6% (Pure sub)
    addBuff(dgn, 'atk', 0.06, 999, 'DGN Excellent Twins ATK');
    // Fluorescent Shield trigger flags
    dgn.fluorShield50Used = false;
    dgn.fluorShield30Used = false;
}

// ‚îÄ‚îÄ DGN Fluorescent Shield ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function triggerFluorShield(dgn) {
    // +20% Holy Damage for 6 rounds (skill effect, not offsettable ‚Äî use addBuff with high rounds)
    addBuff(dgn, 'hd', 0.20, 6, 'DGN Fluorescent Shield Holy');
    log(`‚ú® [DGN FLUOR SHIELD] +20% Holy Damage 6r`, '#c084fc');
}

// ‚îÄ‚îÄ DGN Active: Dance of Shadowland ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fireDGNActive(dgn, isBoss, r) {
    if (!isBoss) return;
    const dc = getDmgCalcInputs();
    if (!dc) return;

    const attrCount = getDGNAttrCount();
    const atkBuff    = getBuffTotal(dgn, 'atk');
    const allDmgBuff = getBuffTotal(dgn, 'allDmg');
    const holyBuff   = dc.holy / 100 + getBuffTotal(dgn, 'hd');
    const critBuff   = dc.crit / 100 + getBuffTotal(dgn, 'crit');
    const precCapped = Math.min(dc.prec / 100, 1.50);
    const cdCapped   = Math.min(dc.cd / 100 + getBuffTotal(dgn, 'cd'), 1.50);
    const corrMult   = 1 + 0.24 * (boss.abyssalCorruption || 0);
    const critMult   = 1.5 * cdCapped * 2 * corrMult;
    const gkMult     = dc.gk ? 2.0 : 1.0;
    const defMult    = (dc.defier && bossHPTier === 'above70') ? 1.3 : 1.0;
    const templeMult = 1 + dc.temple / 100;
    const shrinkMult = boss.shrink ? 1.4 : 1.0;
    const allDmgMult = 1 + allDmgBuff + dc.alldmg / 100;
    const modMult    = allDmgMult * gkMult * defMult * templeMult * shrinkMult;
    const dgnSkill   = window.optimizerContext ? (dgn.art === 'Antlers' ? 300 : dgn.art === 'Antiwarrior' ? 50 : 0) : 0;

    // Main hit: (1400% + 1000% √ó attrCount) skill multiplier
    const mainMultPct = 14 + attrCount * 10; // in units of 100% (so 14 = 1400%)
    const baseMain = dc.atk
        * (1 + atkBuff)
        * (mainMultPct + (dc.skill + dgnSkill) / 100)
        * (1 + precCapped * 0.3)
        * (1 + holyBuff * 0.7)
        * allDmgMult * gkMult * defMult * templeMult * shrinkMult;
    const mainCrit = Math.random() < critBuff;
    const mainHit  = mainCrit ? baseMain * critMult : baseMain;

    let totalDmg = mainHit;
    let srcMain = mainHit, srcUndying = 0, srcLostHP = 0, srcLethal = 0, srcBS = 0, srcAddl = 0;
    let hitLog = [`Main hit (${(mainMultPct*100).toFixed(0)}%+${attrCount}√ó1000% attr): ${Math.round(mainHit).toLocaleString()}${mainCrit?' CRIT':''}`];

    // 70% Undying Shadow bonus (cannot crit, skill effect so not offsettable by curse)
    if (boss.undyingShadow) {
        srcUndying = mainHit * 0.70 * modMult;
        totalDmg  += srcUndying;
        hitLog.push(`Undying Shadow (70% of main √ó modMult): ${Math.round(srcUndying).toLocaleString()}`);
    }

    // Deep Sub: 30% of boss lost HP, capped at 1500% ATK √ó modMult
    const bossLostHP = (1 - (boss.hp || 100) / 100) * (boss.maxHP || 1e15);
    const lostHPDmg  = Math.min(bossLostHP * 0.30, dc.atk * 15) * modMult;
    srcLostHP = lostHPDmg;
    totalDmg += lostHPDmg;
    hitLog.push(`Deep Sub lost HP (30% lost HP, cap 1500% ATK): ${Math.round(lostHPDmg).toLocaleString()}`);

    const preLFBase = totalDmg;

    // Lethal Fightback: 18% of all prior √ó modMult (always fires)
    srcLethal = preLFBase * 0.18 * modMult;
    totalDmg += srcLethal;
    hitLog.push(`Lethal Fightback (18%): ${Math.round(srcLethal).toLocaleString()}`);

    // Balanced Strike: fires if main hit did NOT crit
    if (!mainCrit) {
        const bsPct = bossHPTier === 'below50' ? 1.95 : 0.45;
        srcBS = preLFBase * bsPct * modMult;
        totalDmg += srcBS;
        hitLog.push(`Balanced Strike (${(bsPct*100).toFixed(0)}%, no crit): ${Math.round(srcBS).toLocaleString()}`);
    } else {
        hitLog.push(`Balanced Strike: skipped (main hit crit)`);
    }

    // Additional Multiplier: 80% proc if not sealed
    if (dgn.cc.seal <= 0 && Math.random() < 0.80) {
        srcAddl = (preLFBase + srcLethal + srcBS) * 0.10 * modMult;
        totalDmg += srcAddl;
        hitLog.push(`Additional Multiplier (80% proc, 10%): ${Math.round(srcAddl).toLocaleString()}`);
    }

    // Guiding Glow: +16% ATK, +20% Holy, +16% DR, +20% CD (skill effect stacks, not offsettable)
    addBuff(dgn, 'atk', 0.16, 2, 'DGN Guiding Glow ATK');
    addBuff(dgn, 'hd',  0.20, 2, 'DGN Guiding Glow Holy');
    addBuff(dgn, 'dr',  0.16, 2, 'DGN Guiding Glow DR');
    addBuff(dgn, 'cd',  0.20, 2, 'DGN Guiding Glow CD');
    const bbTarget = units.find(u => u.brightBlessing);
    if (bbTarget && bbTarget !== dgn) {
        addBuff(bbTarget, 'atk', 0.16, 2, 'DGN Guiding Glow ATK (BB)');
        addBuff(bbTarget, 'hd',  0.20, 2, 'DGN Guiding Glow Holy (BB)');
        addBuff(bbTarget, 'dr',  0.16, 2, 'DGN Guiding Glow DR (BB)');
        addBuff(bbTarget, 'cd',  0.20, 2, 'DGN Guiding Glow CD (BB)');
        log(`&nbsp;&nbsp;&nbsp;‚ú® [DGN GUIDING GLOW] ${bbTarget.name} (BB) +16%ATK +20%Holy +16%DR +20%CD 2r`, '#c084fc');
    }
    log(`&nbsp;&nbsp;&nbsp;‚ú® [DGN GUIDING GLOW] DGN +16%ATK +20%Holy +16%DR +20%CD 2r`, '#c084fc');

    // Replicate 2 random debuffs from DGN onto boss (attribute reductions on DGN herself)
    // In a boss fight DGN likely has no debuffs on herself, so this is typically 0
    // but if boss applies debuffs to DGN they get spread here

    // Log
    log(`&nbsp;&nbsp;&nbsp;üåë [DGN ACTIVE] Dance of Shadowland | AttrReductions: ${attrCount} | ${hitLog.join(' | ')}`, '#c084fc');
    log(`&nbsp;&nbsp;&nbsp;üåë [DGN ACTIVE TOTAL] ${Math.round(totalDmg).toLocaleString()}`, '#facc15');

    dgn.totalEstDmg = (dgn.totalEstDmg || 0) + totalDmg;
    if (dgn.dmgPerRound) dgn.dmgPerRound[r-1] = (dgn.dmgPerRound[r-1] || 0) + totalDmg;
    dgn.srcMain    = (dgn.srcMain    || 0) + srcMain;
    dgn.srcUndying = (dgn.srcUndying || 0) + srcUndying;
    dgn.srcLostHP  = (dgn.srcLostHP  || 0) + srcLostHP;
    dgn.srcLethal  = (dgn.srcLethal  || 0) + srcLethal;
    dgn.srcBS      = (dgn.srcBS      || 0) + srcBS;
    dgn.srcAddl    = (dgn.srcAddl    || 0) + srcAddl;
}

// ‚îÄ‚îÄ DGN Basic: Ode of Holylight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fireDGNBasic(dgn, r) {
    const dc = getDmgCalcInputs();
    if (!dc) return;

    const attrCount  = getDGNAttrCount();
    const atkBuff    = getBuffTotal(dgn, 'atk');
    const allDmgBuff = getBuffTotal(dgn, 'allDmg');
    const holyBuff   = dc.holy / 100 + getBuffTotal(dgn, 'hd');
    const critBuff   = dc.crit / 100 + getBuffTotal(dgn, 'crit');
    const precCapped = Math.min(dc.prec / 100, 1.50);
    const cdCapped   = Math.min(dc.cd / 100 + getBuffTotal(dgn, 'cd'), 1.50);
    const corrMult   = 1 + 0.24 * (boss.abyssalCorruption || 0);
    const critMult   = 1.5 * cdCapped * 2 * corrMult;
    const gkMult     = dc.gk ? 2.0 : 1.0;
    const defMult    = (dc.defier && bossHPTier === 'above70') ? 1.3 : 1.0;
    const templeMult = 1 + dc.temple / 100;
    const shrinkMult = boss.shrink ? 1.4 : 1.0;
    const allDmgMult = 1 + allDmgBuff + dc.alldmg / 100;
    const modMult    = allDmgMult * gkMult * defMult * templeMult * shrinkMult;
    const dgnSkill   = window.optimizerContext ? (dgn.art === 'Antlers' ? 300 : dgn.art === 'Antiwarrior' ? 50 : 0) : 0;

    const mainMultPct = 12 + attrCount * 10; // 1200% + 1000% √ó attrCount
    const baseMain = dc.atk
        * (1 + atkBuff)
        * (mainMultPct + (dc.skill + dgnSkill) / 100)
        * (1 + precCapped * 0.3)
        * (1 + holyBuff * 0.7)
        * allDmgMult * gkMult * defMult * templeMult * shrinkMult;
    const mainCrit = Math.random() < critBuff;
    const mainHit  = mainCrit ? baseMain * critMult : baseMain;

    let totalDmg = mainHit, preLF = mainHit;
    let srcLethal = 0, srcBS = 0, srcAddl = 0;

    // Lethal Fightback
    srcLethal = preLF * 0.18 * modMult;
    totalDmg += srcLethal;

    // Balanced Strike if no crit
    if (!mainCrit) {
        const bsPct = bossHPTier === 'below50' ? 1.95 : 0.45;
        srcBS = preLF * bsPct * modMult;
        totalDmg += srcBS;
    }

    // Additional Multiplier
    if (dgn.cc.seal <= 0 && Math.random() < 0.80) {
        srcAddl = (preLF + srcLethal + srcBS) * 0.10 * modMult;
        totalDmg += srcAddl;
    }

    // Deep sub: Armor -18% on boss
    boss.armorDebuff = (boss.armorDebuff || 0) + 0.18; boss.armorDebuffRounds = 2;

    // Replicate 2 random buffs from DGN to Bright Blessing ally (can be DGN herself)
    const bbTarget = units.find(u => u.brightBlessing);
    if (bbTarget) {
        const buffTypes = ['atk','hd','cd','crit','dr','ci','spd','armor'];
        const dgnBuffs = buffTypes.filter(t => getBuffTotal(dgn, t) > 0);
        const shuffled = dgnBuffs.sort(() => Math.random() - 0.5).slice(0, 2);
        shuffled.forEach(t => {
            const val = getBuffTotal(dgn, t);
            if (val > 0) addBuff(bbTarget, t, val, 2, `DGN Basic Replicate ${t}`);
        });
        if (shuffled.length > 0) log(`&nbsp;&nbsp;&nbsp;‚ú® [DGN BASIC] Replicated ${shuffled.join(', ')} to ${bbTarget.name}${bbTarget === dgn ? ' (self)' : ''}`, '#c084fc');
    }

    log(`&nbsp;&nbsp;&nbsp;üåë [DGN BASIC] Ode of Holylight | AttrReductions: ${attrCount} | Main (${(mainMultPct*100).toFixed(0)}%): ${Math.round(mainHit).toLocaleString()}${mainCrit?' CRIT':''} | Total: ${Math.round(totalDmg).toLocaleString()}`, '#c084fc');

    dgn.totalEstDmg = (dgn.totalEstDmg || 0) + totalDmg;
    if (dgn.dmgPerRound) dgn.dmgPerRound[r-1] = (dgn.dmgPerRound[r-1] || 0) + totalDmg;
}

// ‚îÄ‚îÄ DGN Double Nature counter (fires when boss uses active) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function triggerDGNDoubleNature(dgn, r) {
    const dc = getDmgCalcInputs();
    if (!dc) return;
    const atkBuff    = getBuffTotal(dgn, 'atk');
    const allDmgBuff = getBuffTotal(dgn, 'allDmg');
    const allDmgMult = 1 + allDmgBuff + dc.alldmg / 100;
    const gkMult     = dc.gk ? 2.0 : 1.0;
    const defMult    = (dc.defier && bossHPTier === 'above70') ? 1.3 : 1.0;
    const templeMult = 1 + dc.temple / 100;
    const shrinkMult = boss.shrink ? 1.4 : 1.0;
    const modMult    = allDmgMult * gkMult * defMult * templeMult * shrinkMult;

    const counter = dc.atk * (1 + atkBuff) * 10 * modMult; // 1000% ATK
    dgn.totalEstDmg = (dgn.totalEstDmg || 0) + counter;
    if (dgn.dmgPerRound) dgn.dmgPerRound[r-1] = (dgn.dmgPerRound[r-1] || 0) + counter;

    // Apply debuffs
    boss.critDebuff = (boss.critDebuff || 0) + 0.28; boss.critDebuffRounds = 2;
    boss.atkDebuff  = (boss.atkDebuff  || 0) + 0.06; boss.atkDebuffRounds = 4;
    log(`&nbsp;&nbsp;&nbsp;üåë [DGN DOUBLE NATURE] Counter: ${Math.round(counter).toLocaleString()} | Boss Crit -28% 2r, ATK -6% 4r`, '#c084fc');

    // Replicate 2 random Attribute Reductions from boss back onto boss (refreshes/stacks debuffs)
    const attrTypes = ['atkDebuff','armorDebuff','drDebuff','ciDebuff','spdDebuff','critDebuff','healReduction'];
    const activeAttrs = attrTypes.filter(t => (boss[t] || 0) > 0);
    const shuffled = [...activeAttrs].sort(() => Math.random() - 0.5).slice(0, 2);
    shuffled.forEach(t => {
        // Refresh duration of this debuff
        const roundsKey = t === 'healReduction' ? 'healReductionRounds' : t + 'Rounds';
        if (boss[roundsKey] !== undefined) boss[roundsKey] = Math.max(boss[roundsKey] || 0, 2);
    });
    if (shuffled.length > 0) log(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üåë [DOUBLE NATURE] Replicated ${shuffled.join(', ')} back to boss`, '#c084fc');
}

// ‚îÄ‚îÄ DGN Transition (end of round) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fireDGNTransition(dgn, r) {
    if (!dgn || dgn.cc.seal > 0) return;

    // Comet Hop: 50% chance +1 Transition Power
    if (Math.random() < 0.50) {
        dgn.transPower = (dgn.transPower || 0) + 1;
        log(`&nbsp;&nbsp;&nbsp;‚ú® [DGN COMET HOP] +1 Transition Power ‚Üí ${dgn.transPower}`, '#c084fc');
    }

    // Sun Halo: +15% ATK to self for 2r
    addBuff(dgn, 'atk', 0.15, 2, 'DGN Sun Halo ATK');

    const tp = dgn.transPower || 0;

    if (tp >= 12) {
        // 12-stack: consume 12, apply 3 debuffs, deal 2000% ATK √ó total debuff count
        dgn.transPower -= 12;
        boss.atkDebuff  = (boss.atkDebuff  || 0) + 0.50; boss.atkDebuffRounds  = 3;
        boss.critDebuff = (boss.critDebuff || 0) + 0.50; boss.critDebuffRounds = 3;
        boss.ciDebuff   = (boss.ciDebuff   || 0) + 0.50; boss.ciDebuffRounds   = 3;
        log(`&nbsp;&nbsp;&nbsp;üåë [DGN MOON ABYSS 12] Boss ATK -50% 3r, Crit -50% 3r, CI -50% 3r`, '#c084fc');

        const dc = getDmgCalcInputs();
        if (dc) {
            const totalDebuffs = [
                boss.atkDebuff, boss.armorDebuff, boss.drDebuff, boss.ciDebuff,
                boss.spdDebuff, boss.critDebuff, boss.healReduction,
                boss.bleed?.length, boss.burn, boss.watcherMark
            ].filter(v => v && v > 0).length;
            const moonDmg = dc.atk * (1 + getBuffTotal(dgn, 'atk')) * 20 * totalDebuffs; // 2000% √ó count
            dgn.totalEstDmg = (dgn.totalEstDmg || 0) + moonDmg;
            if (dgn.dmgPerRound) dgn.dmgPerRound[r-1] = (dgn.dmgPerRound[r-1] || 0) + moonDmg;
            log(`&nbsp;&nbsp;&nbsp;üåë [DGN MOON ABYSS 12] Extra dmg: ${Math.round(moonDmg).toLocaleString()} (${totalDebuffs} debuffs √ó 2000% ATK)`, '#facc15');
        }
    } else if (tp >= 3) {
        // 3-stack: consume 3, apply 1 random debuff
        dgn.transPower -= 3;
        const roll = Math.floor(Math.random() * 3);
        if (roll === 0)      { boss.atkDebuff   = (boss.atkDebuff   || 0) + 0.30; boss.atkDebuffRounds   = 2; log(`&nbsp;&nbsp;&nbsp;üåë [DGN TRANS] Boss ATK -30% 2r`, '#c084fc'); }
        else if (roll === 1) { boss.spdDebuff   = (boss.spdDebuff   || 0) + 50;   boss.spdDebuffRounds   = 2; log(`&nbsp;&nbsp;&nbsp;üåë [DGN TRANS] Boss SPD -50 2r`, '#c084fc'); }
        else                 { boss.armorDebuff = (boss.armorDebuff || 0) + 0.80; boss.armorDebuffRounds = 2; log(`&nbsp;&nbsp;&nbsp;üåë [DGN TRANS] Boss Armor -80% 2r`, '#c084fc'); }
    }

    // Glowed Glory: extra dmg to frontline (boss) = 20% max HP, cap 1500% ATK
    const dc = getDmgCalcInputs();
    if (dc) {
        const glowDmg = Math.min((boss.maxHP || 1e15) * 0.20, dc.atk * 15);
        dgn.totalEstDmg = (dgn.totalEstDmg || 0) + glowDmg;
        if (dgn.dmgPerRound) dgn.dmgPerRound[r-1] = (dgn.dmgPerRound[r-1] || 0) + glowDmg;
        log(`&nbsp;&nbsp;&nbsp;üåë [DGN GLOWED GLORY] ${Math.round(glowDmg).toLocaleString()} (20% boss HP, cap 1500% ATK)`, '#c084fc');
    }
}

// ‚îÄ‚îÄ CI helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const STELLAR_HEROES = ["LFA","SQH","STV","BDSM","LBRM","DGN"];
const ART_CI_BONUS   = { "Spiritual Mirror": 20, "Scissors": 24, "Jade Toad": 32 };

function getGlobalCI() {
    return (parseFloat(document.getElementById('seTrainCI')?.value) || 0)
         + (parseFloat(document.getElementById('petCI')?.value) || 0);
}
function getEffectiveCI(i) {
    const hero    = document.getElementById(`h${i}`)?.value || '';
    const art     = document.getElementById(`a${i}`)?.value || '';
    const base    = parseFloat(document.getElementById(`ci${i}`)?.value) || 0;
    const stellar = document.getElementById(`stellar${i}`)?.checked && STELLAR_HEROES.includes(hero) ? 35 : 0;
    const artCI   = ART_CI_BONUS[art] || 0;
    return base + stellar + artCI + getGlobalCI();
}
function updateAllCardCI() {
    const tot = getGlobalCI();
    const el = document.getElementById('globalCITotal');
    if (el) el.textContent = tot > 0 ? `Total global bonus: +${tot}% CI to all heroes` : '';
    for (let i = 0; i < 6; i++) updateCardCI(i);
}

function updateCardCI(i) {
    const hero = document.getElementById(`h${i}`)?.value || '';
    const lbl  = document.getElementById(`stellarLbl${i}`);
    if (lbl) lbl.style.display = STELLAR_HEROES.includes(hero) ? '' : 'none';
    const eff = getEffectiveCI(i);
    const el  = document.getElementById(`effCI${i}`);
    if (el) el.textContent = `‚Üí ${eff}%`;
}
</script>
</body>
</html>
